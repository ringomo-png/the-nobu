<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NOBUYUKIQUEST - ÂÜíÈô∫„ÅÆÊõ∏</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background-color: #1a1a1a; color: #fff; font-family: 'DotGothic16', sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; }
        #game-container { position: relative; display: flex; flex-direction: column; width: 1000px; max-width: 100vw; height: 100vh; background: #1a1a1a; }
        #game-area { position: relative; flex: 1; background: #1a1a1a; overflow: hidden; border-bottom: 2px solid #333; border-top: 2px solid #333; }
        
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; position: relative; z-index: 2; }
        
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; font-size: 18px; text-shadow: 2px 2px 0 #000; display: none; }
        #val-score { color: #ffd700; margin-left: 15px; }
        #val-lv { color: #00f3ff; margin-right: 15px; }
        .retro-hp { color: #fff; margin-top: 5px; }
        .heart-icon { color: #ff3b30; }

        #message-box { height: 90px; background-color: #1a1a1a; border: 2px solid #555; border-radius: 6px; margin: 10px; padding: 12px 15px; box-sizing: border-box; font-size: 18px; line-height: 1.5; color: #fff; display: flex; align-items: flex-start; }
        
        .blink { animation: blinker 1.5s linear infinite; }
        #message-box .blink { margin-left: auto; align-self: flex-end; }
        @keyframes blinker { 50% { opacity: 0.4; } }

        #title-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: flex; flex-direction: column; align-items: center; z-index: 50; box-sizing: border-box; padding-top: 3vh; overflow-y: auto; }
        
        .stats-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 600px; margin-bottom: 2vh; }
        .stats-box { border: 2px dashed #555; border-radius: 8px; background: rgba(30,30,30,0.8); padding: 15px; font-size: 16px; color: #ccc; text-align: center; flex: 1; min-width: 200px; }
        .stat-val { color: #ff3b30; font-size: 20px; font-weight: bold; margin: 0 5px; }
        .stat-rate { color: #00f3ff; font-size: 20px; font-weight: bold; margin: 0 5px; }
        
        .leaderboard-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 14px; }
        .leaderboard-list li { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding: 4px 0; }
        .rank-1 { color: #ffd700; font-weight: bold; } .rank-2 { color: #c0c0c0; font-weight: bold; } .rank-3 { color: #cd7f32; font-weight: bold; }

        .start-prompt { 
            font-size: clamp(24px, 5vw, 40px); 
            color: #fff; margin: 2vh auto; cursor: pointer; padding: 15px 4vw; 
            border: 3px solid #fff; border-radius: 10px; background: #222; 
            transition: 0.2s; pointer-events: auto; font-weight: bold; 
            white-space: nowrap; text-align: center; box-sizing: border-box; display: inline-block;
        }
        .start-prompt:active { background: #fff; color: #000; }
        
        .sys-btn-title { font-size: 16px; color: #888; cursor: pointer; pointer-events: auto; text-decoration: underline; margin-bottom: 20px; margin-top: auto; }
        .sys-btn-title:hover { color: #fff; }

        /* „Éë„ÉÅ„É≥„Ç≥È¢®„Ç´„ÉÉ„Éà„Ç§„É≥ */
        #cutin-container { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; justify-content: center; align-items: center; overflow: hidden; background: rgba(0,0,0,0.3); }
        #cutin-img { width: 100%; height: 100%; object-fit: contain; opacity: 0; transform: scale(1.5); filter: brightness(1.2); }
        @keyframes pachinkoCutin {
            0% { opacity: 0; transform: scale(2) translateX(100px); }
            15% { opacity: 1; transform: scale(1) translateX(0); filter: brightness(1.5) drop-shadow(0 0 20px #ff0); }
            85% { opacity: 1; transform: scale(1.05) translateX(-10px); filter: brightness(1.2) drop-shadow(0 0 10px #f00); }
            100% { opacity: 0; transform: scale(1.5) translateX(-100px); }
        }
        .animate-cutin { animation: pachinkoCutin 1.2s cubic-bezier(0.1, 0.8, 0.2, 1) forwards; }

        #system-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        .sys-box { border: 2px solid #555; padding: 25px; background: #1a1a1a; text-align: center; font-size: 16px; max-height: 85vh; overflow-y: auto; border-radius: 8px; }
        .sys-box-inner { text-align: right; margin-bottom: 20px; line-height: 1.8; }
        .sys-box input, .sys-box select { width: 60px; font-size: 16px; margin-left: 10px; background: #222; color: #fff; border: 1px solid #555; text-align: center; font-family: 'DotGothic16'; }

        #gameover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .gameover-text { color: #ff3b30; font-size: 32px; margin-bottom: 40px; font-weight: bold; letter-spacing: 2px; }
        .go-btn { font-size: 24px; color: #fff; margin: 10px; cursor: pointer; padding: 10px 30px; border: 2px solid #fff; transition: 0.2s; background: #222; pointer-events: auto; }
        .go-btn:active { background: #fff; color: #000; }

        #transition-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: none; justify-content: center; align-items: center; z-index: 300; font-size: 40px; letter-spacing: 4px; }

        #ending-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; justify-content: center; align-items: center; z-index: 400; overflow: hidden; cursor: pointer; }
        #ending-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.4; pointer-events: none; }
        #credits { position: absolute; width: 100%; text-align: center; color: #fff; font-size: 24px; line-height: 2; z-index: 401; animation: scrollUp 15s linear forwards; pointer-events: none; }
        @keyframes scrollUp { 0% { transform: translateY(100vh); } 100% { transform: translateY(-100vh); } }

        .assets { display: none; }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="title-screen">
            <svg width="800" height="150" viewBox="0 0 900 200" style="max-width: 90vw; margin-bottom: 2vh;">
                <path id="title-curve" d="M 50,150 Q 450,-20 850,150" fill="transparent" />
                <text font-family="'DotGothic16', sans-serif" font-size="90" fill="#fff" font-weight="bold" filter="drop-shadow(5px 5px 0 #444)">
                    <textPath href="#title-curve" startOffset="50%" text-anchor="middle">NOBUYUKIQUEST</textPath>
                </text>
            </svg>
            
            <div class="stats-container">
                <div class="stats-box">
                    <div style="color:#ffd700; margin-bottom:10px;">„Äê „Åõ„Åã„ÅÑ„Éá„Éº„Çø „Äë</div>
                    Ê≠ª‰∫°Êï∞: <span class="stat-val" id="global-deaths">-</span> Âõû<br>
                    „ÇØ„É™„Ç¢Áéá: <span class="stat-rate" id="global-clear-rate">-.-</span> %
                </div>
                
                <div class="stats-box">
                    <div style="color:#ffd700; margin-bottom:10px;">„Äê „Åà„ÅÑ„ÇÜ„ÅÜ„ÅÆ „Åç„Çç„Åè „Äë</div>
                    <ul class="leaderboard-list" id="leaderboard-list">
                        <li>„Çà„Åø„Åì„Åø„Å°„ÇÖ„ÅÜ...</li>
                    </ul>
                </div>
            </div>

            <div class="start-prompt blink" id="start-btn">Ôºû „Åº„ÅÜ„Åë„Çì „Å´ „Åß„Çã Ôºú</div>
            
            <div class="sys-btn-title" id="open-sys" style="color:#ffd700;">‚öôÔ∏è „ÇØ„É©„Ç¶„Éâ „Ç∑„Çπ„ÉÜ„É†Ë®≠ÂÆö</div>
        </div>

        <div id="system-screen">
            <div class="sys-box">
                <div style="color:#ffd700; margin-bottom:15px; font-size:22px;">„Äê „ÇØ„É©„Ç¶„Éâ „Éê„É©„É≥„ÇπË®≠ÂÆö „Äë</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:15px;">‚ÄªÂ§âÊõ¥„ÅØÂÖ®„Éó„É¨„Ç§„É§„Éº„Å´ÂèçÊò†„Åï„Çå„Åæ„Åô</div>
                <div class="sys-box-inner">
                    BOSS 1 HP: <input type="number" id="hp-boss1" value="30"><br>
                    BOSS 2 HP: <input type="number" id="hp-boss2" value="50"><br>
                    BOSS 3 HP: <input type="number" id="hp-boss3" value="100"><br>
                    BOSS 3 Ââç„ÅÆ„Ç∂„Ç≥Êï∞: <input type="number" id="sys-zako3" value="15"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    Êïµ„ÅÆÁÇé„ÅÆÂ§ß„Åç„Åï(ÂÄçÁéá): <input type="number" id="sys-fire-size" value="1.2" step="0.1"><br>
                    „Éë„É™„Ç£Âà§ÂÆö„ÅÆÂ∫É„Åï: <input type="number" id="sys-parry" value="10"><br>
                    „Éë„É™„Ç£ÊàêÂäüÊôÇ„ÅÆÊîªÊíÉÂäõ: <input type="number" id="sys-parry-dmg" value="5"><br>
                    ÊîªÊíÉ„ÅÆÁ°¨Áõ¥(F): <input type="number" id="sys-cooldown" value="25"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    „Ç´„ÉÉ„Éà„Ç§„É≥ÊºîÂá∫: <select id="sys-cutin"><option value="1">ON</option><option value="0">OFF</option></select><br>
                    BOSS 3 „É¨„Ç§„É≥„Éú„ÉºÁÇéÁ¢∫Áéá(%): <input type="number" id="sys-rainbow-prob" value="10"><br>
                    BOSS 3 ÈÄöÂ∏∏ÊôÇ Á∑ëÁÇé(ÂøÖ„ÅöÊõ≤„Åå„Çã)Á¢∫Áéá(%): <input type="number" id="sys-curve-prob" value="20"><br>
                    BOSS 3 Áô∫ÁãÇ„É¢„Éº„ÉâÁ™ÅÂÖ•HP(%): <input type="number" id="sys-mad-hp" value="50"><br>
                    BOSS 3 Áô∫ÁãÇÊôÇ Êõ≤„Åå„ÇãÁ¢∫Áéá(%): <input type="number" id="sys-mad-prob" value="40"><br>
                </div>
                <button id="close-sys" style="cursor:pointer; font-family:'DotGothic16'; font-size:18px; color:#fff; background:#222; border:2px solid #fff; padding:8px 30px;">„Åª„Åû„Çì„Åó„Å¶ „ÇÇ„Å©„Çã</button>
            </div>
        </div>

        <div id="transition-screen">STAGE 2</div>

        <div id="ending-screen">
            <video id="ending-video" src="game2.MOV" playsinline muted loop></video>
            <div id="credits">
                <br><br><br><br>
                NOBUYUKIQUEST<br><br><br>
                „Åô„Åπ„Å¶„ÅÆ „Åæ„ÇÇ„ÅÆ„Çí „Å®„ÅÜ„Å∞„Å§„Åó„ÅüÔºÅ<br><br><br>
                DIRECTOR / NOBUYUKI<br><br>
                PROGRAM / AI<br><br><br><br>
                THANK YOU FOR PLAYING<br><br><br><br><br>
                <span style="font-size:16px;">Ôºû „Çø„ÉÉ„Éó„Åß „Çø„Ç§„Éà„É´„Å∏ Ôºú</span>
            </div>
        </div>

        <div id="game-area">
            <div id="ui">
                <div>„Çπ„ÉÜ„Éº„Ç∏Ôºö<span id="val-lv">Ôºë</span></div>
                <div class="retro-hp">„ÅÑ„ÅÆ„Å°Ôºö<span class="heart-icon">‚ô•</span> √ó <span id="val-lives">3</span> <span id="val-score">SCORE: 0</span></div>
            </div>
            
            <div id="gameover-screen">
                <div class="gameover-text">„ÅÇ„Å™„Åü„ÅØ „Åó„Çì„Åß„Åó„Åæ„Å£„Åü</div>
                <div class="go-btn" id="btn-retry">Ôºû „Éú„Çπ„Åã„Çâ „É™„Éà„É©„Ç§</div>
                <div class="go-btn" id="btn-title">Ôºû „Çø„Ç§„Éà„É´„Å∏ „ÇÇ„Å©„Çã</div>
            </div>

            <div id="cutin-container">
                <img id="cutin-img" src="game1.png">
            </div>

            <canvas id="view-canvas"></canvas>
        </div>

        <div id="message-box">
            <span id="msg-text">„Éª„Éª„Éª„Éª„Éª„Éª„ÄÇ</span>
            <span class="blink" id="msg-cursor" style="display:none;">‚ñº</span>
        </div>
    </div>

    <div class="assets">
        <img id="walk1" src="1-uma.nobu.png"><img id="walk2" src="2-uma.nobu.png">
        <img id="sword1" src="3-uma.nobu.png"><img id="sword2" src="4-uma.nobu.png"><img id="sword3" src="5-uma.nobu.png">
        <img id="monster1" src="monster1.png"><img id="monster2" src="monster2.png"><img id="monster3" src="monster3.png">
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, increment, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDrDTNLFOC93bBsjzcBrdLt4miPgrat2zY",
            authDomain: "nobuyukiquest.firebaseapp.com",
            projectId: "nobuyukiquest",
            storageBucket: "nobuyukiquest.firebasestorage.app",
            messagingSenderId: "504992212070",
            appId: "1:504992212070:web:79f0ccca4e1d136bd639a7"
        };

        let db;
        try { 
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            loadGlobalStats(); 
            loadLeaderboard(); 
            loadConfig(); 
        } catch(e) { console.log("Firebase Error", e); }

        // üåü „ÇØ„É©„Ç¶„Éâ„ÅÆ„Ç∑„Çπ„ÉÜ„É†Ë®≠ÂÆöÂ§âÊï∞„ÅÆÂÆöÁæ©
        let bossHP = [30, 50, 100];
        let boss3Zako = 15; 
        let fireScale = 1.2; 
        let parryWindow = 10;
        let parryDamage = 5; 
        let baseCooldown = 25;
        let sysRainbowProb = 0.10; 
        let sysCurveProb = 0.20;   
        let sysMadHpRatio = 0.50;  // Áô∫ÁãÇÁ™ÅÂÖ•HP
        let sysMadProb = 0.40;     // Áô∫ÁãÇÊôÇÊõ≤„Åå„ÇãÁ¢∫Áéá
        let sysCutinEnabled = true;

        async function loadConfig() {
            if(!db) return;
            try {
                const docRef = doc(db, "config", "global");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    bossHP[0] = data.hpBoss1 ?? 30;
                    bossHP[1] = data.hpBoss2 ?? 50;
                    bossHP[2] = data.hpBoss3 ?? 100;
                    boss3Zako = data.boss3Zako ?? 15;
                    fireScale = data.fireScale ?? 1.2;
                    parryWindow = data.parryWindow ?? 10;
                    parryDamage = data.parryDamage ?? 5;
                    baseCooldown = data.cooldown ?? 25;
                    sysRainbowProb = (data.rainbowProb ?? 10) / 100;
                    sysCurveProb = (data.curveProb ?? 20) / 100;
                    sysMadHpRatio = (data.madHpRatio ?? 50) / 100;
                    sysMadProb = (data.madProb ?? 40) / 100;
                    sysCutinEnabled = data.cutinEnabled !== false;
                    
                    document.getElementById('hp-boss1').value = bossHP[0];
                    document.getElementById('hp-boss2').value = bossHP[1];
                    document.getElementById('hp-boss3').value = bossHP[2];
                    document.getElementById('sys-zako3').value = boss3Zako;
                    document.getElementById('sys-fire-size').value = fireScale;
                    document.getElementById('sys-parry').value = parryWindow;
                    document.getElementById('sys-parry-dmg').value = parryDamage;
                    document.getElementById('sys-cooldown').value = baseCooldown;
                    document.getElementById('sys-rainbow-prob').value = Math.round(sysRainbowProb * 100);
                    document.getElementById('sys-curve-prob').value = Math.round(sysCurveProb * 100);
                    document.getElementById('sys-mad-hp').value = Math.round(sysMadHpRatio * 100);
                    document.getElementById('sys-mad-prob').value = Math.round(sysMadProb * 100);
                    document.getElementById('sys-cutin').value = sysCutinEnabled ? "1" : "0";
                    
                    currentCooldownMax = baseCooldown;
                }
            } catch(e) { console.error("Config Load Error", e); }
        }

        async function saveConfig() {
            if(!db) return;
            try {
                await setDoc(doc(db, "config", "global"), {
                    hpBoss1: parseInt(document.getElementById('hp-boss1').value),
                    hpBoss2: parseInt(document.getElementById('hp-boss2').value),
                    hpBoss3: parseInt(document.getElementById('hp-boss3').value),
                    boss3Zako: parseInt(document.getElementById('sys-zako3').value),
                    fireScale: parseFloat(document.getElementById('sys-fire-size').value),
                    parryWindow: parseInt(document.getElementById('sys-parry').value),
                    parryDamage: parseInt(document.getElementById('sys-parry-dmg').value),
                    cooldown: parseInt(document.getElementById('sys-cooldown').value),
                    rainbowProb: parseInt(document.getElementById('sys-rainbow-prob').value),
                    curveProb: parseInt(document.getElementById('sys-curve-prob').value),
                    madHpRatio: parseInt(document.getElementById('sys-mad-hp').value),
                    madProb: parseInt(document.getElementById('sys-mad-prob').value),
                    cutinEnabled: document.getElementById('sys-cutin').value === "1"
                });
                await loadConfig(); 
                alert("„ÇØ„É©„Ç¶„Éâ„Å´„Éê„É©„É≥„ÇπË®≠ÂÆö„Çí‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ");
            } catch(e) { console.error("Config Save Error", e); }
        }

        async function loadGlobalStats() {
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    document.getElementById('global-deaths').innerText = data.deaths || 0;
                    let rate = data.plays > 0 ? ((data.clears || 0) / data.plays) * 100 : 0;
                    document.getElementById('global-clear-rate').innerText = rate.toFixed(1);
                } else { await setDoc(docRef, { plays: 0, deaths: 0, clears: 0 }); }
            } catch (e) {}
        }

        async function updateStat(type) { 
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                await setDoc(docRef, { [type]: increment(1) }, { merge: true });
                if(type === 'deaths' || type === 'clears') loadGlobalStats();
            } catch (e) {}
        }

        async function loadLeaderboard() {
            if(!db) return;
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(5));
                const querySnapshot = await getDocs(q);
                const list = document.getElementById('leaderboard-list');
                list.innerHTML = '';
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const li = document.createElement('li');
                    let rankClass = rank <= 3 ? `rank-${rank}` : '';
                    let safeName = data.name.replace(/</g, "&lt;").replace(/>/g, "&gt;").substring(0, 8);
                    li.innerHTML = `<span class="${rankClass}">#${rank} ${safeName}</span> <span style="color:#00f3ff;">${data.score}pt</span>`;
                    list.appendChild(li);
                    rank++;
                });
                if(list.innerHTML === '') list.innerHTML = '<li>„Åæ„Å† „Åç„Çç„Åè „Åå „ÅÇ„Çä„Åæ„Åõ„Çì</li>';
            } catch(e) {}
        }

        const canvas = document.getElementById('view-canvas'); 
        const ctx = canvas.getContext('2d');
        const GW = 1000, GH = 400; const PLAYER_X = 50; const CHAR_SIZE = 180;
        const UPPER_Y = 280, LOWER_Y = 340; 

        let gameState = 'TITLE', currentLevel = 1, score = 0, frameCount = 0, lives = 3;
        let phase = 'zako', zakoKills = 0, enemies = [], swordWaves = [], projectiles = [], boss = null;
        let attackFrame = -1, attackCooldown = 0, currentCooldownMax = baseCooldown, playerTint = '', playerTintTimer = 0;
        let diedAtBoss = false;
        let waitFrames = 0, waitCallback = null, shake = 0, flash = 0; 
        
        let attackPower = 1; 
        let powerUpTimer = 0;
        let invincibleTimer = 0; 
        let cutinTimer = 0; 
        let zakoTimer = 0;       

        const imgWalk = [document.getElementById('walk1'), document.getElementById('walk2')];
        const imgSword = [document.getElementById('sword1'), document.getElementById('sword2'), document.getElementById('sword3')];
        const imgMonsters = [document.getElementById('monster1'), document.getElementById('monster2'), document.getElementById('monster3')];

        let audioCtx, audioInitialized = false, bgmInterval, titleBgmInterval;
        
        function initAudio() {
            if (!audioInitialized || audioCtx.state === 'suspended') {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                audioInitialized = true;
                if(gameState === 'TITLE' && !titleBgmInterval) playTitleBgm();
            }
        }
        window.addEventListener('mousedown', initAudio, { once: true });
        window.addEventListener('touchstart', initAudio, { once: true });

        function playSound(type) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const now = audioCtx.currentTime;

            if(type === 'slash'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.6, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'hit'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.8, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'parry'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.2);
            }
            if(type === 'heal'){
                const notes = [659.25, 880.00, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + i*0.08); gain.gain.linearRampToValueAtTime(0.4, now + i*0.08 + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.08 + 0.3);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now + i*0.08); osc.stop(now + i*0.08 + 0.3);
                });
            }
            if(type === 'damage'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4);
            }
            if(type === 'player_dead'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now + 1.0);
                gain.gain.setValueAtTime(1.0, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.0);
                
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 800;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(1.0, now); noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }
            if(type === 'boss_dead'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(10, now + 2.0);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 2.0);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 2.0);
            }
            if(type === 'cutin'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
            }
            if(type === 'gameover'){
                const startTime = now + 0.8; 
                const notes = [196.00, 185.00, 174.61, 130.81];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'triangle'; osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, startTime + i*0.4); gain.gain.linearRampToValueAtTime(0.7, startTime + i*0.4 + 0.1); gain.gain.exponentialRampToValueAtTime(0.01, startTime + i*0.4 + 1.0);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(startTime + i*0.4); osc.stop(startTime + i*0.4 + 1.0);
                });
            }
        }

        function playTitleBgm(){ 
            if(titleBgmInterval) clearInterval(titleBgmInterval);
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const melody = [440.00, 523.25, 659.25, 523.25]; 
            titleBgmInterval = setInterval(()=>{ 
                const now = audioCtx.currentTime; const osc=audioCtx.createOscillator(); const g=audioCtx.createGain(); 
                osc.type='square'; osc.frequency.value=melody[frameCount%4]; 
                g.gain.setValueAtTime(0.08,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                osc.connect(g); g.connect(audioCtx.destination); osc.start(now); osc.stop(now+0.15); 
            }, 220); 
        }
        function stopTitleBgm(){ if(titleBgmInterval) clearInterval(titleBgmInterval); titleBgmInterval=null; }
        
        function startBgm(){ 
            if(bgmInterval) clearInterval(bgmInterval);
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            bgmInterval = setInterval(()=>{ 
                if(gameState !== 'PLAYING') return; 
                if(cutinTimer > 0) return; 
                
                const now = audioCtx.currentTime;
                
                let melody, bass;
                if(currentLevel === 3) {
                    melody = [130.81, 138.59, 146.83, 138.59]; 
                    bass = [65.41, 69.30, 73.42, 69.30];     
                } else {
                    melody = [146.83, 164.81, 174.61, 196.00]; 
                    bass = [73.42, 73.42, 87.31, 87.31];
                }

                const mOsc=audioCtx.createOscillator(); const mG=audioCtx.createGain(); 
                mOsc.type='square'; mOsc.frequency.value=melody[frameCount%4]; 
                mG.gain.setValueAtTime(0.1,now); mG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                mOsc.connect(mG); mG.connect(audioCtx.destination); mOsc.start(now); mOsc.stop(now+0.15); 
                
                const bOsc=audioCtx.createOscillator(); const bG=audioCtx.createGain(); 
                bOsc.type='triangle'; bOsc.frequency.value=bass[frameCount%4]; 
                bG.gain.setValueAtTime(0.15,now); bG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                bOsc.connect(bG); bG.connect(audioCtx.destination); bOsc.start(now); bOsc.stop(now+0.15); 
            }, 180); 
        }
        function stopBgm(){ if(bgmInterval) clearInterval(bgmInterval); bgmInterval=null; }

        function showMsg(t, blinkCursor = false) { document.getElementById('msg-text').innerText = t; document.getElementById('msg-cursor').style.display = blinkCursor ? 'inline-block' : 'none'; }
        function toZen(num) { return num.toString().replace(/[0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0)); }
        function getStageName(lv) { return lv === 1 ? "Ôºë" : (lv === 2 ? "Ôºí" : "„Éï„Ç°„Ç§„Éä„É´"); }

        function drawBackground(ctx, level, frame) {
            ctx.save(); const groundY = 280; 
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, GW, GH); 
            ctx.strokeStyle = currentLevel === 3 ? '#600' : '#333'; 
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(GW, groundY); ctx.stroke(); 
            ctx.fillStyle = currentLevel === 3 ? '#311' : '#222';
            ctx.fillRect(0, groundY, GW, GH - groundY); 
            ctx.fillStyle = currentLevel === 3 ? '#422' : '#333';
            for(let i=0; i<GW; i+=80) ctx.fillRect((i - frame*6)%GW, groundY+20, 30, 2);
            for(let i=30; i<GW; i+=100) ctx.fillRect((i - frame*8)%GW, groundY+50, 40, 2);
            ctx.restore();
        }

        function resetGame(retryBoss = false) {
            stopBgm(); stopTitleBgm(); 
            if(!retryBoss){ 
                currentLevel=1; score=0; zakoKills=0; updateStat('plays'); 
            } else {
                score = 0; 
            }
            
            lives=3; enemies=[]; swordWaves=[]; projectiles=[]; boss=null; 
            attackFrame=-1; waitFrames=0; playerTintTimer=0; diedAtBoss=false;
            shake=0; flash=0; currentCooldownMax = baseCooldown;
            attackPower = 1; powerUpTimer = 0; cutinTimer = 0; invincibleTimer = 0;
            zakoTimer = 60;
            
            document.getElementById('ui').style.display='block'; updateUI(); 
            startBgm();
            
            if(retryBoss) {
                phase='wait_boss'; 
                showMsg("„Éú„Çπ„Å®„ÅÆ „Åï„ÅÑ„Åõ„Çì „Å†ÔºÅ(„Çπ„Ç≥„Ç¢ 0 „Åã„Çâ)"); waitFrames = 60; waitCallback = spawnBoss;
            } else {
                phase='zako'; showMsg("„Åº„ÅÜ„Åë„Çì „Åå „ÅØ„Åò„Åæ„Å£„ÅüÔºÅ");
            }
        }

        function spawnBoss(){
            boss = { x:GW+200, y:290, hp:bossHP[currentLevel-1], maxHp:bossHP[currentLevel-1], w:180, h:180, timer:-90, targetX:GW-150, shake:0, attackCount:0, restTimer:0, attackCooldown: 60, cutinDone: false };
            phase = 'boss'; showMsg(currentLevel>=3?"„Åï„ÅÑ„Åó„ÇÖ„ÅÜ „Éú„Çπ „Åå „ÅÇ„Çâ„Çè„Çå„ÅüÔºÅÔºÅ":"„Åç„Çá„ÅÜ„Çä„Çá„Åè„Å™ „Éú„Çπ „Åå „ÅÇ„Çâ„Çè„Çå„ÅüÔºÅ");
        }

        function showCutin() {
            playSound('cutin');
            const cutin = document.getElementById('cutin-container');
            const img = document.getElementById('cutin-img');
            cutin.style.display = 'flex';
            img.classList.add('animate-cutin');
            setTimeout(() => {
                cutin.style.display = 'none';
                img.classList.remove('animate-cutin');
            }, 1200);
        }

        function updateUI() {
            document.getElementById('val-lives').innerText = toZen(lives);
            document.getElementById('val-score').innerText = "SCORE: " + score;
            document.getElementById('val-lv').innerText = getStageName(currentLevel);
        }

        function drawCrescent(obj, shadowColor, fillColor = '#fff') { ctx.save(); ctx.translate(obj.x, obj.y); ctx.fillStyle = fillColor; ctx.shadowBlur = 15; ctx.shadowColor = shadowColor; ctx.beginPath(); ctx.moveTo(0, -35); ctx.quadraticCurveTo(20, 0, 0, 35); ctx.quadraticCurveTo(8, 0, 0, -35); ctx.fill(); ctx.restore(); }
        function drawHeart(x, y, size) { ctx.save(); ctx.translate(x, y - size/4); ctx.fillStyle = '#ff69b4'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(-size/2, -size/2, -size, size/3, 0, size); ctx.bezierCurveTo(size, size/3, size/2, -size/2, 0, 0); ctx.fill(); ctx.restore(); }

        function animate() {
            requestAnimationFrame(animate); 
            
            let bgFrame = (cutinTimer > 0) ? 0 : frameCount; 
            drawBackground(ctx, currentLevel, bgFrame); ctx.imageSmoothingEnabled = false; 

            if (gameState !== 'PLAYING' && gameState !== 'GAMEOVER_WAIT' && gameState !== 'CLEAR') { frameCount++; return; }
            if (waitFrames > 0) { waitFrames--; if (waitFrames === 0 && waitCallback) { let cb = waitCallback; waitCallback = null; cb(); } }
            if (shake > 0) { shake *= 0.8; if (shake < 0.5) shake = 0; } if (flash > 0) { flash *= 0.8; if (flash < 0.01) flash = 0; }
            if (playerTintTimer > 0) playerTintTimer--;

            ctx.save(); if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            
            if (cutinTimer > 0) {
                cutinTimer--;
            } else {
                // =============== ÊôÇÈñìÈÄ≤Ë°å ===============
                if (attackCooldown > 0) attackCooldown--;
                if (powerUpTimer > 0) {
                    powerUpTimer--;
                    if(invincibleTimer <= 0) { playerTint = `hsla(0, 100%, 50%, 0.3)`; playerTintTimer = 2; }
                    if (powerUpTimer === 0) { attackPower = 1; showMsg("„Åì„ÅÜ„Åí„Åç„Çä„Çá„Åè „Åå „ÇÇ„Å®„Å´„ÇÇ„Å©„Å£„Åü„ÄÇ"); }
                }
                if (invincibleTimer > 0) {
                    invincibleTimer--;
                    playerTint = `hsla(${frameCount * 30 % 360}, 100%, 70%, 0.6)`; playerTintTimer = 2; 
                }

                // --- BOSS UPDATE ---
                if (boss && (phase === 'boss' || phase === 'boss_dead')) {
                    if (phase === 'boss') boss.timer++; 
                    if (boss.timer > 0 && phase === 'boss') {
                        if (boss.x > boss.targetX) boss.x -= 3;
                        if (boss.shake > 0) { boss.shake *= 0.8; if(boss.shake < 0.5) boss.shake = 0; }
                        
                        if (boss.restTimer > 0) { 
                            boss.restTimer--; 
                        } else {
                            if (boss.attackCooldown > 0) boss.attackCooldown--;
                            if (boss.attackCooldown <= 0 && boss.x <= boss.targetX && gameState === 'PLAYING') {
                                let isUp = Math.random() < 0.5;
                                let isFeint = false;
                                let pColor = 'normal';

                                // üåü ÊúÄÁµÇ„Éú„Çπ„ÅÆÊîªÊíÉ„Éë„Çø„Éº„É≥ÔºàÁô∫ÁãÇ„ÉªÈÄöÂ∏∏Ôºâ
                                if (currentLevel === 3) {
                                    if (Math.random() < sysRainbowProb) {
                                        pColor = 'rainbow';
                                        isFeint = false;
                                    } else if ((boss.hp / boss.maxHp) < sysMadHpRatio) {
                                        // üåü Áô∫ÁãÇ„É¢„Éº„ÉâÔºöËµ§Èªí„ÅÑÁÇé„ÄÅ„É©„É≥„ÉÄ„É†„ÅßÊõ≤„Åå„Çã
                                        pColor = 'redblack';
                                        isFeint = Math.random() < sysMadProb; 
                                    } else {
                                        // üåü ÈÄöÂ∏∏„É¢„Éº„Éâ
                                        if (Math.random() < sysCurveProb) {
                                            pColor = 'green';
                                            isFeint = true;  // Á∑ë„ÅØÂøÖ„ÅöÊõ≤„Åå„Çã
                                        } else {
                                            pColor = 'blue';
                                            isFeint = false; // Èùí„ÅØÁµ∂ÂØæ„Å´Êõ≤„Åå„Çâ„Å™„ÅÑ
                                        }
                                    }
                                }

                                let startY = isUp ? UPPER_Y : LOWER_Y; 
                                let endY = isFeint ? (isUp ? LOWER_Y : UPPER_Y) : startY;
                                let pSpeed = currentLevel === 3 ? 16 : 12 + (currentLevel * 2);

                                projectiles.push({ x: boss.x + (Math.random()-0.5)*boss.shake, y: startY, targetY: endY, speed: pSpeed, isParried: false, color: pColor });
                                
                                let nextRate = Math.max(30, 70 - (currentLevel * 10));
                                if (currentLevel === 3) nextRate = baseCooldown + 25 + Math.floor(Math.random() * 30);
                                else nextRate = Math.max(nextRate, baseCooldown + 15);
                                boss.attackCooldown = nextRate;

                                boss.attackCount++; 
                                if (boss.attackCount >= (currentLevel === 3 ? 6 + Math.random()*4 : 4 + Math.random()*2)) { 
                                    boss.restTimer = 100; boss.attackCount = 0; 
                                }
                            }
                        }
                    }
                }

                // --- PROJECTILES UPDATE ---
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    let p = projectiles[i]; p.x -= p.speed; 
                    if (!p.isParried && p.y !== p.targetY && p.x < GW / 2 + 100) { p.y += (p.targetY > p.y) ? 12 : -12; if (Math.abs(p.y - p.targetY) < 12) p.y = p.targetY; }
                    
                    if (p.x < PLAYER_X + 60 && !p.isParried && gameState === 'PLAYING') { 
                        if (p.color === 'rainbow') {
                            projectiles.splice(i, 1); 
                            playSound('heal'); flash = 0.5;
                            // üåü „É¨„Ç§„É≥„Éú„Éº„É´„Éº„É¨„ÉÉ„ÉàÔºà3ÊäûÔºâ
                            let r = Math.floor(Math.random() * 3);
                            if (r === 0) {
                                attackPower = 1.5; powerUpTimer = 300; // üåü 5ÁßíÈñì
                                showMsg("„É¨„Ç§„É≥„Éú„ÉºÁÇéÔºÅ 5„Å≥„Çá„ÅÜ„Åã„Çì „Åì„ÅÜ„Åí„Åç„Çä„Çá„Åè„Ç¢„ÉÉ„ÉóÔºÅ");
                            } else if (r === 1) {
                                if(lives < 3) lives++;
                                showMsg("„É¨„Ç§„É≥„Éú„ÉºÁÇéÔºÅ „ÅÑ„ÅÆ„Å° „Åå „Åã„ÅÑ„Åµ„Åè„Åó„ÅüÔºÅ");
                            } else {
                                invincibleTimer = 180; // 3ÁßíÁÑ°Êïµ
                                showMsg("„É¨„Ç§„É≥„Éú„ÉºÁÇéÔºÅ 3„Å≥„Çá„ÅÜ„Åã„Çì „ÇÄ„Å¶„ÅçÔºÅ");
                            }
                            updateUI(); 
                        } else {
                            projectiles.splice(i, 1); damagePlayer(); break; 
                        }
                    }
                    else if (p.isParried && boss && phase === 'boss' && p.x > boss.x - boss.w/2) { 
                        projectiles.splice(i, 1); boss.hp -= (parryDamage * attackPower); boss.shake = 20; playSound('hit'); score += 50; updateUI(); 
                        
                        if (currentLevel === 3 && boss.hp > 0 && boss.hp <= boss.maxHp * 0.1 && !boss.cutinDone) {
                            boss.cutinDone = true; 
                            if(sysCutinEnabled) { cutinTimer = 72; showCutin(); }
                        }

                        if (boss.hp <= 0) { win(); break; } 
                    }
                    else if (p.x < -100 || p.x > GW + 200) projectiles.splice(i, 1);
                }

                // --- ENEMIES UPDATE ---
                if(phase === 'zako') {
                    zakoTimer--;
                    if (zakoTimer <= 0) {
                        enemies.push({ x: GW + 50, y: Math.random() < 0.5 ? UPPER_Y : LOWER_Y, speed: 10 + (currentLevel * 2), type: Math.random() < 0.05 ? 'heal' : 'normal' });
                        
                        // üåü Ââ£„ÅÆÁ°¨Áõ¥ÊôÇÈñìÔºã5„ÅÆ„ÄåÁµ∂ÂØæ„Å´ÂÆâÂÖ®„Å†„ÅåË∂ÖÁã≠„ÅÑ„Éû„Éº„Ç∏„É≥„Äç
                        let minWait = currentCooldownMax + 5; 
                        if (currentLevel === 3) {
                            zakoTimer = minWait + Math.floor(Math.random() * 15); // +0ÔΩû14„Éï„É¨„Éº„É†„ÅÆ„ÅøÔºà„Åã„Å™„ÇäÁã≠„ÅÑÔºÅÔºâ
                        } else {
                            zakoTimer = Math.max(minWait, 60 - (currentLevel * 10)); 
                        }
                    }
                }

                for (let i = enemies.length - 1; i >= 0; i--) {
                    let e = enemies[i]; if (gameState === 'PLAYING' && phase !== 'transition') e.x -= e.speed;
                    
                    if (e.x < PLAYER_X + 80 && gameState === 'PLAYING' && phase !== 'transition') {
                        if (e.type === 'heal') { 
                            if (lives < 3) lives++; showMsg("„ÅÑ„ÅÆ„Å°„ÅÆ„Åç„ÅÆ„Åø „Çí „Å¶„Å´ÂÖ•„Çå„ÅüÔºÅ „ÅÑ„ÅÆ„Å°„Åå „Åã„ÅÑ„Åµ„Åè„Åó„ÅüÔºÅ"); playSound('heal'); playerTint = 'rgba(0, 255, 0, 0.5)'; playerTintTimer = 15; updateUI(); 
                        } else { damagePlayer(); }
                        enemies.splice(i, 1); 
                        if (gameState !== 'PLAYING') break; 
                    } else if (e.x < -100) { enemies.splice(i, 1); }
                }

                // --- SWORD WAVES UPDATE ---
                for (let i = swordWaves.length - 1; i >= 0; i--) {
                    let sw = swordWaves[i]; sw.x += 10; 
                    
                    let hitSomething = false;
                    for(let j = enemies.length - 1; j >= 0; j--) {
                        let e = enemies[j];
                        if (Math.abs(sw.x - e.x) < 80 && Math.abs(sw.y - e.y) < 30) { 
                            if (e.type === 'heal') { playSound('hit'); } 
                            else { 
                                playSound('hit'); score += 10; zakoKills++; updateUI(); 
                                if(phase === 'zako' && zakoKills >= (currentLevel === 3 ? boss3Zako : 5)) { 
                                    phase = 'wait_boss'; showMsg("„Éª„Éª„Éª„Éª„Éª„Éª„ÄÇ"); waitFrames = 120; waitCallback = spawnBoss; 
                                } 
                            }
                            enemies.splice(j, 1); hitSomething = true; break; 
                        } 
                    }
                    if(hitSomething){ swordWaves.splice(i, 1); continue; }

                    for(let j = projectiles.length - 1; j >= 0; j--) {
                        let p = projectiles[j];
                        if (!p.isParried && Math.abs(sw.x - p.x) < parryWindow && Math.abs(sw.y - p.y) < 30) { 
                            hitSomething = true;
                            if (p.x < PLAYER_X + 220) { p.isParried = true; p.speed = -40; playSound('parry'); score += 50; updateUI(); shake = 10; flash = 0.3; } 
                            else { projectiles.splice(j, 1); playSound('hit'); score += 10; updateUI(); shake = 5; }
                            break;
                        } 
                    }
                    if(hitSomething){ swordWaves.splice(i, 1); continue; }

                    if (boss && phase === 'boss' && Math.abs(sw.x - boss.x) < boss.w/2) { 
                        boss.hp -= (1 * attackPower); boss.shake = 10; swordWaves.splice(i, 1); shake = 10; playSound('hit'); 
                        
                        if (currentLevel === 3 && boss.hp > 0 && boss.hp <= boss.maxHp * 0.1 && !boss.cutinDone) {
                            boss.cutinDone = true; 
                            if(sysCutinEnabled) { cutinTimer = 72; showCutin(); }
                        }

                        if (boss.hp <= 0) { win(); break; } 
                    }
                    else if (sw.x > GW + 100) swordWaves.splice(i, 1);
                }

                // --- PLAYER UPDATE ---
                if (attackFrame >= 0) { attackFrame++; if (attackFrame >= 12) attackFrame = -1; }
            } // ======== Êõ¥Êñ∞Âá¶ÁêÜ„Åì„Åì„Åæ„Åß ========

            // =============== ÊèèÁîªÂá¶ÁêÜ ===============
            
            if (boss && (phase === 'boss' || phase === 'boss_dead')) {
                let bx = boss.x + (Math.random() - 0.5) * boss.shake; let by = boss.y + (Math.random() - 0.5) * boss.shake;
                const bossImg = imgMonsters[Math.min(currentLevel - 1, 2)];
                if (bossImg && bossImg.complete && bossImg.naturalWidth > 0) { ctx.drawImage(bossImg, bx - boss.w/2, by - boss.h/2, boss.w, boss.h); } else { ctx.fillStyle = '#222'; ctx.fillRect(bx - boss.w/2, by - boss.h/2, boss.w, boss.h); }
                
                if(phase === 'boss') {
                    ctx.fillStyle = '#111'; ctx.fillRect(GW/2 - 150, 15, 300, 10); ctx.fillStyle = '#ff3b30'; ctx.fillRect(GW/2 - 150, 15, 300 * (boss.hp/boss.maxHp), 10);
                    ctx.fillStyle = '#fff'; ctx.font = '16px DotGothic16'; ctx.textAlign = 'center'; ctx.fillText('BOSS', GW/2, 10); ctx.textAlign = 'left';
                }
            }

            for (let i = 0; i < projectiles.length; i++) {
                let p = projectiles[i];
                if (p.isParried) { 
                    drawCrescent(p, '#ff8800', '#ffff00'); 
                } else {
                    ctx.save(); ctx.translate(p.x, p.y); ctx.scale(fireScale, fireScale);
                    if (p.color === 'rainbow') {
                        ctx.fillStyle = `hsl(${frameCount * 15 % 360}, 100%, 50%)`; ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = '#fff'; ctx.fillRect(-6, -6, 12, 12);
                    } else if (p.color === 'redblack') {
                        // üåü Ëµ§Èªí„ÅÑÁÇéÔºàÁô∫ÁãÇ„É¢„Éº„ÉâÔºâ
                        ctx.fillStyle = '#111'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#a00'; ctx.fillRect(-6, -6, 12, 12); 
                        ctx.fillStyle = '#000'; ctx.fillRect(-2, -2, 4, 4);
                    } else if (p.color === 'blue') {
                        ctx.fillStyle = '#0000ff'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#0088ff'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#00ffff'; ctx.fillRect(-2, -2, 4, 4);
                    } else if (p.color === 'green') {
                        ctx.fillStyle = '#008800'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#00ff00'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#aaffaa'; ctx.fillRect(-2, -2, 4, 4);
                    } else {
                        ctx.fillStyle = '#ff0000'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#ff8800'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#ffff00'; ctx.fillRect(-2, -2, 4, 4);
                    }
                    ctx.restore();
                }
            }

            for (let i = 0; i < enemies.length; i++) {
                let e = enemies[i];
                if (e.type === 'heal') { drawHeart(e.x, e.y, 25); } 
                else { ctx.fillStyle = currentLevel === 3 ? '#ccc' : '#444'; ctx.beginPath(); ctx.ellipse(e.x, e.y, 30, 25, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#ff0055'; ctx.fillRect(e.x - 15, e.y - 5, 8, 3); }
            }

            for (let i = 0; i < swordWaves.length; i++) { drawCrescent(swordWaves[i], '#00f3ff'); }

            let currentImg;
            if (attackFrame >= 0) { const idx = Math.floor(attackFrame / 4); currentImg = imgSword[Math.min(idx, 2)]; } else { currentImg = imgWalk[Math.floor(frameCount / 10) % 2]; }
            
            if (currentImg && currentImg.complete && currentImg.naturalWidth > 0) { 
                const pw = CHAR_SIZE * (currentImg.naturalWidth/currentImg.naturalHeight); const py = GH - CHAR_SIZE - 20;
                ctx.save(); ctx.drawImage(currentImg, PLAYER_X, py, pw, CHAR_SIZE); 
                if (playerTintTimer > 0) { ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = playerTint; ctx.fillRect(PLAYER_X, py, pw, CHAR_SIZE); }
                ctx.restore();
            }

            ctx.restore();
            if (flash > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${flash*0.5})`; ctx.fillRect(0, 0, GW, GH); }
            
            if (gameState === 'PLAYING' && cutinTimer <= 0) frameCount++;
        }

        function damagePlayer() {
            if (gameState !== 'PLAYING') return;
            if (invincibleTimer > 0) return; // ÁÑ°Êïµ‰∏≠„ÅØ„Éé„Éº„ÉÄ„É°„Éº„Ç∏
            
            lives--; updateUI(); shake = 30; flash = 0.4; playSound('damage'); playerTint = 'rgba(255, 0, 0, 0.6)'; playerTintTimer = 15;
            if (lives <= 0) {
                gameState = 'GAMEOVER_WAIT'; stopBgm(); playSound('player_dead'); playSound('gameover');    
                diedAtBoss = (phase === 'boss' || phase === 'boss_dead'); 
                updateStat('deaths'); showMsg("„ÅÇ„Å™„Åü„ÅØ „Åó„Çì„Åß„Åó„Åæ„Å£„Åü„ÄÇ");
                
                waitFrames = 200; 
                waitCallback = () => { 
                    gameState = 'GAMEOVER_PROMPT'; document.getElementById('btn-retry').style.display = diedAtBoss ? 'block' : 'none'; 
                    document.getElementById('gameover-screen').style.display = 'flex';
                };
            }
        }

        function win() {
            if (gameState !== 'PLAYING') return;
            boss = null; score += 500 * currentLevel; 
            if (lives < 3) lives++; 
            updateUI(); flash = 0.8; playSound('boss_dead'); showMsg("„Éú„Çπ „Çí „Åü„Åä„Åó„ÅüÔºÅ „ÅÑ„ÅÆ„Å° „Åå „Åã„ÅÑ„Åµ„Åè„Åó„ÅüÔºÅ");
            phase = 'boss_dead'; 
            projectiles = []; enemies = []; swordWaves = []; 
            waitFrames = 100; 
            
            waitCallback = () => {
                if (currentLevel >= 3) {
                    gameState = 'ENDING'; stopBgm(); updateStat('clears'); showMsg("„Åô„Åπ„Å¶„ÅÆ „Åæ„ÇÇ„ÅÆ„Çí „Å®„ÅÜ„Å∞„Å§„Åó„ÅüÔºÅ");
                    
                    setTimeout(async () => {
                        let playerName = prompt("„ÇØ„É™„Ç¢„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ\n„Åà„ÅÑ„ÇÜ„ÅÜ„ÅÆ„Åç„Çç„Åè „Å´ ÂêçÂâç„Çí„ÅÆ„Åì„Åù„ÅÜÔºÅ(8ÊñáÂ≠ó„Åæ„Åß)", "„ÇÜ„ÅÜ„Åó„ÇÉ");
                        if (playerName) {
                            try {
                                await addDoc(collection(db, "leaderboard"), { name: playerName || "„Å™„Å™„Åó", score: score, timestamp: Date.now() });
                                loadLeaderboard(); 
                            } catch(e) {}
                        }
                        document.getElementById('ending-screen').style.display = 'flex'; document.getElementById('ending-video').play().catch(e => console.log(e)); 
                    }, 500);

                } else {
                    phase = 'transition'; document.getElementById('transition-screen').style.display = 'flex'; document.getElementById('transition-screen').innerText = `STAGE ${currentLevel + 1}`;
                    waitFrames = 150; 
                    waitCallback = () => { 
                        document.getElementById('transition-screen').style.display = 'none'; 
                        currentLevel++; phase = 'zako'; zakoKills = 0; currentCooldownMax = baseCooldown; 
                        showMsg(`„Çπ„ÉÜ„Éº„Ç∏ ${getStageName(currentLevel)} „Åå „ÅØ„Åò„Åæ„Å£„Åü„ÄÇ`); updateUI(); startBgm(); 
                    };
                }
            };
        }

        const startHandler = (e) => {
            e.preventDefault(); initAudio(); 
            gameState = 'PLAYING'; document.getElementById('title-screen').style.display = 'none'; resetGame();
        };
        document.getElementById('start-btn').addEventListener('mousedown', startHandler);
        document.getElementById('start-btn').addEventListener('touchstart', startHandler, {passive: false});

        document.getElementById('open-sys').onclick = () => {
            initAudio(); 
            let pass = prompt("ÁÆ°ÁêÜËÄÖ„Éë„Çπ„ÉØ„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ (4Ê°Å)");
            if (pass === "1711") { document.getElementById('system-screen').style.display = 'flex'; } 
            else if (pass !== null) { alert("„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÈÅï„ÅÑ„Åæ„Åô"); }
        };

        document.getElementById('close-sys').onclick = () => {
            document.getElementById('system-screen').style.display = 'none';
            saveConfig(); 
        };
        
        document.getElementById('btn-retry').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none'; gameState = 'PLAYING'; resetGame(true);
        };
        document.getElementById('btn-title').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none';
            gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("„Éª„Éª„Éª„Éª„Éª„Éª„ÄÇ"); playTitleBgm();
        };

        document.getElementById('ending-screen').onclick = () => {
            document.getElementById('ending-screen').style.display = 'none';
            gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("„Éª„Éª„Éª„Éª„Éª„Éª„ÄÇ"); playTitleBgm();
        };

        const canvasTap = (e) => {
            if (gameState === 'PLAYING' && phase !== 'transition' && cutinTimer <= 0) {
                if (attackCooldown > 0) return; 
                attackFrame = 0; attackCooldown = currentCooldownMax; 
                let rect = canvas.getBoundingClientRect(); 
                let x = (e.clientX || e.touches[0].clientX) - rect.left;
                x = x * (canvas.width / rect.width);
                swordWaves.push({x: PLAYER_X + 110, y: x < GW/2 ? UPPER_Y : LOWER_Y}); playSound('slash');
            }
        };

        canvas.addEventListener('mousedown', canvasTap);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); canvasTap(e); }, {passive: false});

        canvas.width = GW; canvas.height = GH; 
        
        document.getElementById('title-screen').style.display = 'flex';
        animate();
    </script>
</body>
</html>
