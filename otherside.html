<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NOBUYUKIQUEST - 冒険の書</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background-color: #1a1a1a; color: #fff; font-family: 'DotGothic16', sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100dvh; overflow: hidden; user-select: none; touch-action: none; -webkit-touch-callout: none; }
        #game-container { position: relative; display: flex; flex-direction: column; width: 1000px; max-width: 100vw; height: 100dvh; background: #1a1a1a; }
        #game-area { position: relative; flex: 1; background: #1a1a1a; overflow: hidden; border-bottom: 2px solid #333; border-top: 2px solid #333; }
        
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; position: relative; z-index: 2; }
        
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; font-size: 18px; text-shadow: 2px 2px 0 #000; display: none; }
        #val-score { color: #ffd700; margin-left: 15px; }
        #val-lv { color: #00f3ff; margin-right: 15px; }
        .retro-hp { color: #fff; margin-top: 5px; }
        .heart-icon { color: #ff3b30; }

        #message-box { height: 90px; background-color: #1a1a1a; border: 2px solid #555; border-radius: 6px; margin: 10px 10px 20px 10px; padding: 12px 15px; box-sizing: border-box; font-size: 18px; line-height: 1.5; color: #fff; display: flex; align-items: flex-start; }
        
        .blink { animation: blinker 1.5s linear infinite; }
        #message-box .blink { margin-left: auto; align-self: flex-end; }
        @keyframes blinker { 50% { opacity: 0.4; } }

        #title-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: flex; flex-direction: column; align-items: center; z-index: 50; box-sizing: border-box; padding-top: 2vh; overflow-y: auto; padding-bottom: 20px; }
        
        .stats-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 90%; max-width: 600px; margin-bottom: 2vh; }
        .stats-box { border: 2px dashed #555; border-radius: 8px; background: rgba(30,30,30,0.8); padding: 15px; font-size: 16px; color: #ccc; text-align: center; flex: 1; min-width: 200px; }
        .stat-val { color: #ff3b30; font-size: 20px; font-weight: bold; margin: 0 5px; }
        .stat-rate { color: #00f3ff; font-size: 20px; font-weight: bold; margin: 0 5px; }
        
        .leaderboard-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 14px; max-height: 80px; overflow-y: auto; }
        .leaderboard-list::-webkit-scrollbar { width: 4px; }
        .leaderboard-list::-webkit-scrollbar-thumb { background: #666; border-radius: 2px; }
        .leaderboard-list li { display: flex; justify-content: space-between; align-items: center; gap: 10px; border-bottom: 1px dashed #333; padding: 4px 5px; }
        .rank-1 { color: #ffd700; font-weight: bold; } .rank-2 { color: #c0c0c0; font-weight: bold; } .rank-3 { color: #cd7f32; font-weight: bold; }

        .start-prompt { 
            font-size: clamp(24px, 5vw, 40px); color: #fff; margin: 2vh auto; cursor: pointer; padding: 15px 4vw; 
            border: 3px solid #fff; border-radius: 10px; background: #222; transition: 0.2s; pointer-events: auto; font-weight: bold; 
            white-space: nowrap; text-align: center; box-sizing: border-box; display: inline-block;
        }
        .start-prompt:active { background: #fff; color: #000; }
        
        .bottom-menu { display: flex; gap: 30px; align-items: center; justify-content: center; margin-top: auto; margin-bottom: 15px; }
        .sys-btn-title { font-size: 18px; color: #aaa; cursor: pointer; pointer-events: auto; text-decoration: underline; transition: 0.2s; }
        .sys-btn-title:hover { color: #fff; }

        #user-setting-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        
        #virtual-pad { position: absolute; bottom: 5%; right: 5%; display: none; z-index: 30; pointer-events: none; }
        .v-btn { 
            position: absolute; border-radius: 50%; 
            background: rgba(120, 120, 120, 0.8); border: 6px double #ccc; color: #fff; 
            font-family: 'DotGothic16', sans-serif; 
            display: flex; justify-content: center; align-items: center; 
            pointer-events: auto; cursor: pointer; transition: 0.1s; 
            box-sizing: border-box; 
        }
        .v-btn:active { background: rgba(255, 255, 255, 0.5); color: #000; border-color: #fff; }
        #v-btn-a { top: 0; right: 0; }
        #v-btn-b { bottom: 0; left: 0; }

        #cutin-container { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; pointer-events: none; justify-content: center; align-items: center; overflow: hidden; background: rgba(0,0,0,0.3); }
        #cutin-img { width: 100%; height: 100%; object-fit: contain; opacity: 0; transform: scale(1.5); filter: brightness(1.2); }
        @keyframes pachinkoCutin {
            0% { opacity: 0; transform: scale(2) translateX(100px); }
            15% { opacity: 1; transform: scale(1) translateX(0); filter: brightness(1.5) drop-shadow(0 0 20px #ff0); }
            85% { opacity: 1; transform: scale(1.05) translateX(-10px); filter: brightness(1.2) drop-shadow(0 0 10px #f00); }
            100% { opacity: 0; transform: scale(1.5) translateX(-100px); }
        }
        .animate-cutin { animation: pachinkoCutin 1.2s cubic-bezier(0.1, 0.8, 0.2, 1) forwards; }

        #system-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        .sys-box { border: 2px solid #555; padding: 25px; background: #1a1a1a; text-align: center; font-size: 16px; max-height: 85dvh; overflow-y: auto; border-radius: 8px; }
        .sys-box-inner { text-align: right; margin-bottom: 20px; line-height: 1.8; }
        .sys-box input, .sys-box select { width: 60px; font-size: 16px; margin-left: 10px; background: #222; color: #fff; border: 1px solid #555; text-align: center; font-family: 'DotGothic16'; }

        #gameover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .gameover-text { color: #cc0000; font-size: 60px; margin-bottom: 40px; font-weight: bold; letter-spacing: 5px; font-family: 'DotGothic16', sans-serif; text-shadow: 4px 4px 0 #000; }
        .go-btn { font-size: 24px; color: #fff; margin: 10px; cursor: pointer; padding: 10px 30px; border: 2px solid #fff; transition: 0.2s; background: #222; pointer-events: auto; }
        .go-btn:active { background: #fff; color: #000; }

        #transition-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: none; justify-content: center; align-items: center; z-index: 300; font-size: 40px; letter-spacing: 4px; }

        #ending-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 400; overflow: hidden; }
        .end-seq-text { opacity: 0; transition: opacity 2s ease; font-family: 'DotGothic16', sans-serif; text-align: center; line-height: 1.5; margin-bottom: 10px; color: #fff; font-size: 16px; }
        .end-seq-green { color: #34c759; text-shadow: 0 0 5px rgba(52, 199, 89, 0.5); font-family: 'DotGothic16', monospace; font-size: 16px; letter-spacing: 2px; }
        #ending-terminal, #ending-credits, #ending-the-end { display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; }
        #ending-tap { font-size: 16px; margin-top: 40px; cursor: pointer; pointer-events: auto; }
        #ending-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity 3s ease; pointer-events: none; z-index: -1; }

        .assets { display: none; }

        #back-to-main { position: absolute; top: 15px; left: 15px; z-index: 1000; color: rgba(255, 255, 255, 0.3); text-decoration: none; font-size: 24px; font-weight: bold; font-family: sans-serif; transition: color 0.3s; pointer-events: auto; padding: 10px; }
        #back-to-main:hover { color: rgba(255, 255, 255, 0.9); }

        #story-intro { position: absolute; inset: 0; background: #1a1a1a; z-index: 80; display: flex; justify-content: center; align-items: center; text-align: center; line-height: 2.2; font-size: 16px; transition: opacity 1s ease; cursor: pointer; }
        #story-text { opacity: 0; transition: opacity 2.5s ease; letter-spacing: 2px; text-shadow: 0 0 10px rgba(255,255,255,0.3); }
        .tap-hint { display: block; margin-top: 30px; font-size: 12px; color: #888; animation: blinker 1.5s linear infinite; }
        #title-svg { opacity: 0; transition: opacity 2.5s ease; }
        #title-ui-wrap { opacity: 0; transition: opacity 1.5s ease; width: 100%; display: flex; flex-direction: column; align-items: center; flex: 1; }

        .leaderboard-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
        .leaderboard-score { color: #00f3ff; flex-shrink: 0; }
    </style>
</head>
<body>

    <div id="game-container">
        
        <a href="index.html" id="back-to-main" title="メインに戻る">←</a>

        <video id="title-bgm-video" src="game.MOV" playsinline loop style="display:none;"></video>

        <div id="title-screen">
            
            <div id="story-intro">
                <div id="story-text">
                    西暦20XX年、インフラから見放された街。<br>
                    突如現れた異次元のバグ「魔獣」。<br><br>
                    彼は遊戯台の覚醒条件を解析し、<br>
                    己の肉体へと強制インストールした。<br><br>
                    すべては、あの日の郷愁を守るために――<br>
                    <span class="tap-hint blink">＞ タップして進む ＜</span>
                </div>
            </div>

            <svg id="title-svg" width="800" height="150" viewBox="0 0 900 200" style="max-width: 90vw; margin-bottom: 2vh;">
                <path id="title-curve" d="M 50,150 Q 450,-20 850,150" fill="transparent" />
                <text font-family="'DotGothic16', sans-serif" font-size="90" fill="#fff" font-weight="bold" filter="drop-shadow(5px 5px 0 #444)">
                    <textPath href="#title-curve" startOffset="50%" text-anchor="middle">NOBUYUKIQUEST</textPath>
                </text>
            </svg>
            
            <div id="title-ui-wrap">
                <div class="stats-container">
                    <div class="stats-box">
                        <div style="color:#ffd700; margin-bottom:10px;">【 せかいデータ 】</div>
                        死亡数: <span class="stat-val" id="global-deaths">-</span> 回<br>
                        クリア率: <span class="stat-rate" id="global-clear-rate">-.-</span> %
                    </div>
                    
                    <div class="stats-box">
                        <div style="color:#ffd700; margin-bottom:5px;">【 えいゆうの きろく 】</div>
                        <ul class="leaderboard-list" id="leaderboard-list">
                            <li>よみこみちゅう...</li>
                        </ul>
                    </div>
                </div>

                <div class="start-prompt blink" id="start-btn">＞ ぼうけん に でる ＜</div>
                
                <div class="bottom-menu">
                    <div class="sys-btn-title" id="open-user-setting">せってい</div>
                    <div class="sys-btn-title" id="music-btn">おんがく OFF</div>
                </div>
                <div class="sys-btn-title" id="open-sys" style="color:#888; margin-bottom:10px;">システム設定</div>
            </div>
        </div>

        <div id="user-setting-screen">
            <div class="sys-box">
                <div style="color:#ffd700; margin-bottom:15px; font-size:22px;">【 せってい 】</div>
                <div class="sys-box-inner" style="text-align: left;">
                    BGM: <select id="set-bgm-onoff"><option value="on">ON</option><option value="off">OFF</option></select><br><br>
                    音量: <input type="range" id="set-volume" min="0" max="1" step="0.1" value="0.5" style="vertical-align: middle;"><br><br>
                    操作方法:<br>
                    <select id="set-controls" style="width: auto;">
                        <option value="1">パターン1 (画面の左右をタップ)</option>
                        <option value="2">パターン2 (A・B ボタン)</option>
                    </select><br><br>
                    <div style="font-size:14px; color:#aaa; margin-bottom: 5px;">※A・Bボタンの大きさ</div>
                    サイズ: 
                    <select id="set-btn-size" style="width: auto;">
                        <option value="55">小</option>
                        <option value="75">大</option>
                    </select>
                </div>
                <button id="close-user-setting" style="cursor:pointer; font-family:'DotGothic16'; font-size:18px; color:#fff; background:#222; border:2px solid #fff; padding:8px 30px;">けってい</button>
            </div>
        </div>

        <div id="system-screen">
            <div class="sys-box">
                <div style="color:#ffd700; margin-bottom:15px; font-size:22px;">【 クラウド バランス設定 】</div>
                <div style="font-size:12px; color:#aaa; margin-bottom:15px;">※変更は全プレイヤーに反映されます</div>
                <div class="sys-box-inner">
                    BOSS 1 HP: <input type="number" id="hp-boss1" value="30"><br>
                    BOSS 2 HP: <input type="number" id="hp-boss2" value="50"><br>
                    BOSS 3 HP: <input type="number" id="hp-boss3" value="100"><br>
                    BOSS 3 前のザコ数: <input type="number" id="sys-zako3" value="15"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    敵の炎の大きさ(倍率): <input type="number" id="sys-fire-size" value="1.2" step="0.1"><br>
                    パリィ判定の広さ: <input type="number" id="sys-parry" value="10"><br>
                    パリィ成功時の攻撃力: <input type="number" id="sys-parry-dmg" value="5"><br>
                    攻撃の硬直(F): <input type="number" id="sys-cooldown" value="25"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    カットイン演出: <select id="sys-cutin"><option value="1">ON</option><option value="0">OFF</option></select><br>
                    BOSS 3 レインボー炎確率(%): <input type="number" id="sys-rainbow-prob" value="10"><br>
                    BOSS 3 通常時 緑炎(必ず曲がる)確率(%): <input type="number" id="sys-curve-prob" value="20"><br>
                    BOSS 3 発狂モード突入HP(%): <input type="number" id="sys-mad-hp" value="50"><br>
                    BOSS 3 発狂時 曲がる確率(%): <input type="number" id="sys-mad-prob" value="40"><br>
                </div>
                <button id="close-sys" style="cursor:pointer; font-family:'DotGothic16'; font-size:18px; color:#fff; background:#222; border:2px solid #fff; padding:8px 30px;">ほぞんして もどる</button>
            </div>
        </div>

        <div id="transition-screen">STAGE 2</div>

        <div id="ending-screen">
            <video id="ending-video" src="game2.MOV" playsinline muted></video>
            
            <div id="ending-terminal">
                <div id="end-msg-1" class="end-seq-text">システムの初期化に成功……魔獣は駆逐された</div>
                <div id="end-msg-2" class="end-seq-text">郷愁の街「よつかいどう」に、平和が訪れる</div>
                <div id="end-msg-3" class="end-seq-text">だが、のぶゆきの冒険は、終わらない――</div>
            </div>
            
            <div id="ending-credits">
                <div id="end-cred-1" class="end-seq-text end-seq-green">PRODUCTION : bori's</div>
                <div id="end-cred-2" class="end-seq-text end-seq-green">DIRECTOR / CREATOR : Satoshi Mori</div>
                <div id="end-cred-3" class="end-seq-text end-seq-green">MUSIC : AI</div>
                <div id="end-cred-4" class="end-seq-text end-seq-green">COOPERATION : Nobuyuki Kurosaki</div>
                <div id="end-cred-5" class="end-seq-text end-seq-green">IDEA : Uesugi Kazushi / AI PARTNER : Kairi Nakamura</div>
            </div>
            
            <div id="ending-the-end">
                <div id="end-final-text" class="end-seq-text" style="font-size: 60px; font-family: 'DotGothic16', sans-serif; text-shadow: 4px 4px 0 #000; letter-spacing: 5px;">THE END</div>
                <div id="ending-tap" class="end-seq-text">＞ TAP ＜</div>
            </div>
        </div>

        <div id="game-area">
            <div id="ui">
                <div>ステージ：<span id="val-lv">１</span></div>
                <div class="retro-hp">いのち：<span class="heart-icon">♥</span> × <span id="val-lives">3</span> <span id="val-score">SCORE: 0</span></div>
            </div>

            <div id="virtual-pad">
                <div class="v-btn" id="v-btn-a">A</div>
                <div class="v-btn" id="v-btn-b">B</div>
            </div>
            
            <div id="gameover-screen">
                <div class="gameover-text">YOU DIED</div>
                <div class="go-btn" id="btn-retry">＞ ボスから リトライ</div>
                <div class="go-btn" id="btn-title">＞ タイトルへ もどる</div>
            </div>

            <div id="cutin-container">
                <img id="cutin-img" src="game1.png">
            </div>

            <canvas id="view-canvas"></canvas>
        </div>

        <div id="message-box">
            <span id="msg-text">・・・・・・。</span>
            <span class="blink" id="msg-cursor" style="display:none;">▼</span>
        </div>
    </div>

    <div class="assets">
        <img id="walk1" src="1-uma.nobu.png"><img id="walk2" src="2-uma.nobu.png">
        <img id="sword1" src="3-uma.nobu.png"><img id="sword2" src="4-uma.nobu.png"><img id="sword3" src="5-uma.nobu.png">
        <img id="monster1" src="monster1.png"><img id="monster2" src="monster2.png"><img id="monster3" src="monster3.png">
    </div>

    <script type="module">
                import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        // ★ 最後に「, serverTimestamp」を追加
        import { getFirestore, doc, getDoc, setDoc, increment, collection, addDoc, query, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";


        const firebaseConfig = {
            apiKey: "AIzaSyDrDTNLFOC93bBsjzcBrdLt4miPgrat2zY",
            authDomain: "nobuyukiquest.firebaseapp.com",
            projectId: "nobuyukiquest",
            storageBucket: "nobuyukiquest.firebasestorage.app",
            messagingSenderId: "504992212070",
            appId: "1:504992212070:web:79f0ccca4e1d136bd639a7"
        };

        let db;
        try { 
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            loadGlobalStats(); 
            loadLeaderboard(); 
            loadConfig(); 
        } catch(e) {}

        // 画面初期表示時のスクロール位置リセット処理
        window.addEventListener('DOMContentLoaded', () => {
            window.scrollTo(0, 0); 
            
            const introDiv = document.getElementById('story-intro');
            const storyText = document.getElementById('story-text');
            const titleSvg = document.getElementById('title-svg');
            const titleUiWrap = document.getElementById('title-ui-wrap');

            setTimeout(() => storyText.style.opacity = '1', 500); 

            const advanceIntro = (e) => {
                e.preventDefault();
                
                // Safariでの音声再生制限を解除するためにAudioを初期化します
                initAudio();
                
                introDiv.removeEventListener('click', advanceIntro);
                introDiv.removeEventListener('touchstart', advanceIntro);
                
                storyText.style.opacity = '0'; 
                
                setTimeout(() => {
                    introDiv.style.display = 'none'; 
                    titleSvg.style.opacity = '1';    
                    
                    setTimeout(() => {
                        titleUiWrap.style.opacity = '1'; 
                    }, 1000);
                }, 1000); 
            };

            introDiv.addEventListener('click', advanceIntro);
            introDiv.addEventListener('touchstart', advanceIntro, {passive: false});
        });

        let bossHP = [30, 50, 100];
        let boss3Zako = 15; 
        let fireScale = 1.2; 
        let parryWindow = 10;
        let parryDamage = 5; 
        let baseCooldown = 25;
        let sysRainbowProb = 0.10; 
        let sysCurveProb = 0.20;   
        let sysMadHpRatio = 0.50;  
        let sysMadProb = 0.40;     
        let sysCutinEnabled = true;

        let masterVolume = parseFloat(localStorage.getItem('nq_vol')) || 0.5;
        let isBgmOn = localStorage.getItem('nq_bgm') !== 'false'; 
        let controlPattern = parseInt(localStorage.getItem('nq_ctrl')) || 1; 
        let btnSize = parseInt(localStorage.getItem('nq_btnSize')) || 75; 
        let btnGap = 10; 
        let localDeathCount = 0; 

        document.getElementById('set-volume').value = masterVolume;
        document.getElementById('set-bgm-onoff').value = isBgmOn ? "on" : "off";
        document.getElementById('set-controls').value = controlPattern;
        document.getElementById('set-btn-size').value = btnSize;

        async function loadConfig() {
            if(!db) return;
            try {
                const docRef = doc(db, "config", "global");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    bossHP[0] = data.hpBoss1 ?? 30;
                    bossHP[1] = data.hpBoss2 ?? 50;
                    bossHP[2] = data.hpBoss3 ?? 100;
                    boss3Zako = data.boss3Zako ?? 15;
                    fireScale = data.fireScale ?? 1.2;
                    parryWindow = data.parryWindow ?? 10;
                    parryDamage = data.parryDamage ?? 5;
                    baseCooldown = data.cooldown ?? 25;
                    sysRainbowProb = (data.rainbowProb ?? 10) / 100;
                    sysCurveProb = (data.curveProb ?? 20) / 100;
                    sysMadHpRatio = (data.madHpRatio ?? 50) / 100;
                    sysMadProb = (data.madProb ?? 40) / 100;
                    sysCutinEnabled = data.cutinEnabled !== false;
                    
                    document.getElementById('hp-boss1').value = bossHP[0];
                    document.getElementById('hp-boss2').value = bossHP[1];
                    document.getElementById('hp-boss3').value = bossHP[2];
                    document.getElementById('sys-zako3').value = boss3Zako;
                    document.getElementById('sys-fire-size').value = fireScale;
                    document.getElementById('sys-parry').value = parryWindow;
                    document.getElementById('sys-parry-dmg').value = parryDamage;
                    document.getElementById('sys-cooldown').value = baseCooldown;
                    document.getElementById('sys-rainbow-prob').value = Math.round(sysRainbowProb * 100);
                    document.getElementById('sys-curve-prob').value = Math.round(sysCurveProb * 100);
                    document.getElementById('sys-mad-hp').value = Math.round(sysMadHpRatio * 100);
                    document.getElementById('sys-mad-prob').value = Math.round(sysMadProb * 100);
                    document.getElementById('sys-cutin').value = sysCutinEnabled ? "1" : "0";
                    
                    currentCooldownMax = baseCooldown;
                }
            } catch(e) {}
        }

        async function saveConfig() {
            if(!db) return;
            try {
                await setDoc(doc(db, "config", "global"), {
                    hpBoss1: parseInt(document.getElementById('hp-boss1').value),
                    hpBoss2: parseInt(document.getElementById('hp-boss2').value),
                    hpBoss3: parseInt(document.getElementById('hp-boss3').value),
                    boss3Zako: parseInt(document.getElementById('sys-zako3').value),
                    fireScale: parseFloat(document.getElementById('sys-fire-size').value),
                    parryWindow: parseInt(document.getElementById('sys-parry').value),
                    parryDamage: parseInt(document.getElementById('sys-parry-dmg').value),
                    cooldown: parseInt(document.getElementById('sys-cooldown').value),
                    rainbowProb: parseInt(document.getElementById('sys-rainbow-prob').value),
                    curveProb: parseInt(document.getElementById('sys-curve-prob').value),
                    madHpRatio: parseInt(document.getElementById('sys-mad-hp').value),
                    madProb: parseInt(document.getElementById('sys-mad-prob').value),
                    cutinEnabled: document.getElementById('sys-cutin').value === "1"
                });
                await loadConfig(); 
                alert("クラウドにバランス設定を保存しました！");
            } catch(e) {}
        }

        async function loadGlobalStats() {
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    document.getElementById('global-deaths').innerText = data.deaths || 0;
                    let rate = data.plays > 0 ? ((data.clears || 0) / data.plays) * 100 : 0;
                    document.getElementById('global-clear-rate').innerText = rate.toFixed(1);
                } else { await setDoc(docRef, { plays: 0, deaths: 0, clears: 0 }); }
            } catch (e) {}
        }

        async function updateStat(type) { 
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                await setDoc(docRef, { [type]: increment(1) }, { merge: true });
                if(type === 'deaths' || type === 'clears') loadGlobalStats();
            } catch (e) {}
        }

        async function loadLeaderboard() {
            if(!db) return;
            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(15));
                const querySnapshot = await getDocs(q);
                const list = document.getElementById('leaderboard-list');
                list.innerHTML = '';
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const li = document.createElement('li');
                    let rankClass = rank <= 3 ? `rank-${rank}` : '';
                    let safeName = data.name.replace(/</g, "&lt;").replace(/>/g, "&gt;").substring(0, 8);
                    li.innerHTML = `<span class="${rankClass} leaderboard-name">#${rank} ${safeName}</span> <span class="leaderboard-score">${data.score}pt</span>`;
                    list.appendChild(li);
                    rank++;
                });
                if(list.innerHTML === '') list.innerHTML = '<li>まだ きろく が ありません</li>';
            } catch(e) {}
        }

        const canvas = document.getElementById('view-canvas'); 
        const ctx = canvas.getContext('2d');
        const GW = 1000, GH = 400; const PLAYER_X = 50; const CHAR_SIZE = 180;
        const UPPER_Y = 280, LOWER_Y = 340; 

                        let gameState = 'TITLE', currentLevel = 1, score = 0, frameCount = 0, lives = 3;
        let totalDamageTaken = 0; // ★ ノーダメクリア判定用のカウンター
        let cancelScoreCount = 0; // ★ 追加：弾消しで稼いだ点数を記録するカウンター


        let phase = 'zako', zakoKills = 0, enemies = [], swordWaves = [], projectiles = [], boss = null;
        let attackFrame = -1, attackCooldown = 0, currentCooldownMax = baseCooldown, playerTint = '', playerTintTimer = 0;
        let diedAtBoss = false;
        let waitFrames = 0, waitCallback = null, shake = 0, flash = 0; 
        
        let attackPower = 1; 
        let powerUpTimer = 0;
        let invincibleTimer = 0; 
        let cutinTimer = 0; 
        let zakoTimer = 0;       
        let checkpointScore = 0; 

        const imgWalk = [document.getElementById('walk1'), document.getElementById('walk2')];
        const imgSword = [document.getElementById('sword1'), document.getElementById('sword2'), document.getElementById('sword3')];
        const imgMonsters = [document.getElementById('monster1'), document.getElementById('monster2'), document.getElementById('monster3')];

        let audioCtx, audioInitialized = false, bgmInterval;
        const titleBgmAudio = new Audio('game.MOV');
        titleBgmAudio.loop = true;
        
                function initAudio() {
            if (!audioInitialized) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                audioInitialized = true;
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            // ★スマホの音出し制限を強制突破する「無音再生ハック」
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                gain.gain.value = 0; // ボリューム0（無音）
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(0);
                osc.stop(audioCtx.currentTime + 0.01);
            } catch(e) {}
        }


        const musicBtn = document.getElementById('music-btn');
        musicBtn.onclick = (e) => {
            e.stopPropagation();
            if(titleBgmAudio.paused) {
                titleBgmAudio.volume = masterVolume;
                titleBgmAudio.play().catch(err => console.log(err));
                musicBtn.innerText = "おんがく ON";
            } else {
                titleBgmAudio.pause();
                musicBtn.innerText = "おんがく OFF";
            }
        };

        window.addEventListener('mousedown', initAudio, { once: true });
        window.addEventListener('touchstart', initAudio, { once: true });

        // 非同期処理による待機関数
        const waitMs = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // エンディングのシーケンス制御
        async function playEndingSequence() {
            initAudio();

            if (isBgmOn) {
                titleBgmAudio.volume = masterVolume;
                titleBgmAudio.currentTime = 0;
                titleBgmAudio.play().catch(e => console.log('BGM playback failed:', e));
            }

            const screen = document.getElementById('ending-screen');
            const term = document.getElementById('ending-terminal');
            const creds = document.getElementById('ending-credits');
            const theEnd = document.getElementById('ending-the-end');
            const tapBtn = document.getElementById('ending-tap');
            const vid = document.getElementById('ending-video');
            
            // UIの初期設定
            screen.style.display = 'flex';
            term.style.display = 'flex';
            creds.style.display = 'none';
            theEnd.style.display = 'none';
            vid.style.opacity = '0';
            
            document.querySelectorAll('.end-seq-text').forEach(el => el.style.opacity = '0');
            
            // 冒険の結末テキスト表示
            await waitMs(600);
            document.getElementById('end-msg-1').style.opacity = '1';
            await waitMs(2000);
            document.getElementById('end-msg-2').style.opacity = '1';
            await waitMs(2500);
            document.getElementById('end-msg-3').style.opacity = '1';
            
            await waitMs(3000);
            term.style.display = 'none';
            
            // クレジット表示
            creds.style.display = 'flex';
            await waitMs(500);
            document.getElementById('end-cred-1').style.opacity = '1';
            await waitMs(2200);
            document.getElementById('end-cred-2').style.opacity = '1';
            await waitMs(2500);
            document.getElementById('end-cred-3').style.opacity = '1';
            await waitMs(2500);
            document.getElementById('end-cred-4').style.opacity = '1';
            await waitMs(2500);
            document.getElementById('end-cred-5').style.opacity = '1';
            
            await waitMs(4000);
            creds.style.display = 'none';
            
            // THE END 表示
            theEnd.style.display = 'flex';
            await waitMs(1000);
            document.getElementById('end-final-text').style.opacity = '1';
            
                        // フェイクの TAP ボタン表示
            await waitMs(3000); // 
            tapBtn.style.opacity = '1';
            tapBtn.classList.add('blink'); // 

            
            // タップ時のイベントを登録
                        // タップ時のイベントを登録
            const tapHandler = () => {
                tapBtn.removeEventListener('click', tapHandler);
                tapBtn.removeEventListener('touchstart', tapHandler);
                
                initAudio();
                titleBgmAudio.pause(); 
                
                theEnd.style.display = 'none';
                vid.style.display = 'block';
                vid.muted = false; 
                vid.currentTime = 0;
                vid.play().catch(e => console.log('Video playback failed:', e));
                
                setTimeout(() => { vid.style.opacity = '0.4'; }, 100);
                
                // 追加・変更: タイトルへ戻る処理を関数化し、動画終了時(ended)に発火させる
                const returnTitle = () => {
                    vid.removeEventListener('ended', returnTitle);
                    screen.removeEventListener('click', returnTitle);
                    screen.removeEventListener('touchstart', returnTitle);
                    
                    screen.style.display = 'none';
                    titleBgmAudio.pause();
                    vid.pause();
                    gameState = 'TITLE'; 
                    document.getElementById('ui').style.display = 'none'; 
                    document.getElementById('title-screen').style.display = 'flex'; 
                    showMsg("・・・・・・。"); 
                };

                // 追加: 動画が最後まで再生されたら自動でタイトルに戻る
                vid.addEventListener('ended', returnTitle);
                
                // 変更: 誤タップ防止で2秒待機後、画面タップでもスキップ（タイトルへ戻る）できるようにする
                setTimeout(() => {
                    screen.addEventListener('click', returnTitle);
                    screen.addEventListener('touchstart', returnTitle, {passive: false});
                }, 2000); 
            };

            
            tapBtn.addEventListener('click', tapHandler);
            tapBtn.addEventListener('touchstart', tapHandler, {passive: false});
        }

        function playSound(type) {
            if(!audioCtx || audioCtx.state !== 'running') return;
            const now = audioCtx.currentTime;
            const v = masterVolume; 

            if(type === 'slash'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.6 * v, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'hit'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.8 * v, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'parry'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.9 * v, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.2);
            }
            if(type === 'heal'){
                const notes = [659.25, 880.00, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + i*0.08); gain.gain.linearRampToValueAtTime(0.4 * v, now + i*0.08 + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.08 + 0.3);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now + i*0.08); osc.stop(now + i*0.08 + 0.3);
                });
            }
            if(type === 'levelup'){
                const notes = [
                    {f: 392.00, t: 0, d: 0.1},    
                    {f: 392.00, t: 0.15, d: 0.1}, 
                    {f: 392.00, t: 0.30, d: 0.1}, 
                    {f: 392.00, t: 0.45, d: 0.3}, 
                    {f: 329.63, t: 0.75, d: 0.3}, 
                    {f: 440.00, t: 1.05, d: 0.3}, 
                    {f: 523.25, t: 1.35, d: 0.6}  
                ];
                notes.forEach(n => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'square'; osc.frequency.value = n.f;
                    gain.gain.setValueAtTime(0, now + n.t); 
                    gain.gain.linearRampToValueAtTime(0.3 * v, now + n.t + 0.02); 
                    gain.gain.exponentialRampToValueAtTime(0.01, now + n.t + n.d);
                    osc.connect(gain); gain.connect(audioCtx.destination); 
                    osc.start(now + n.t); osc.stop(now + n.t + n.d);
                });
            }
            if(type === 'damage'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.9 * v, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4);
            }
            if(type === 'boss_appear'){
                [55, 65.41, 73.42].forEach(freq => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, now); osc.frequency.exponentialRampToValueAtTime(freq * 0.8, now + 2.0);
                    gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.5 * v, now + 0.1); gain.gain.exponentialRampToValueAtTime(0.01, now + 2.0);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 2.0);
                });
                const bufferSize = audioCtx.sampleRate * 1.0;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 400;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0, now); noiseGain.gain.linearRampToValueAtTime(1.0 * v, now + 0.1); noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }
                        if(type === 'player_dead'){
                // 【ハッカー特製】ドゥーーーン…という絶望的な音（ベースの急降下）
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; 
                osc.frequency.setValueAtTime(150, now); 
                osc.frequency.exponentialRampToValueAtTime(10, now + 1.2); 
                
                // エラー回避のため、linearRampで安全にフェードアウト！
                gain.gain.setValueAtTime(0, now); 
                gain.gain.linearRampToValueAtTime(1.0 * v, now + 0.05); 
                gain.gain.linearRampToValueAtTime(0, now + 1.2); 
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.2);
                
                // ザザーッというノイズ（Math.floorで小数を切り捨ててエラーを完全防御！）
                const bufferSize = Math.floor(audioCtx.sampleRate * 0.5); 
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 600;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(0, now); 
                noiseGain.gain.linearRampToValueAtTime(0.8 * v, now + 0.05); 
                noiseGain.gain.linearRampToValueAtTime(0, now + 0.5); 
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }

            if(type === 'boss_dead'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(10, now + 2.0);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.9 * v, now + 0.05); gain.gain.exponentialRampToValueAtTime(0.01, now + 2.0);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 2.0);
            }
            if(type === 'cutin'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.5 * v, now + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.5);
            }
                        if(type === 'gameover'){
                const startTime = now + 1.2; // 死の音のあとに鳴らす
                // 【ハッカー特製】絶望のレクイエム（哀愁漂う下降アルペジオ）
                const notes = [
                    {f: 261.63, t: 0, d: 0.2},    // C4
                    {f: 246.94, t: 0.2, d: 0.2},  // B3
                    {f: 233.08, t: 0.4, d: 0.2},  // Bb3
                    {f: 220.00, t: 0.6, d: 0.8}   // A3 (最後は長く伸ばす…)
                ];
                notes.forEach(n => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'square'; // レトロなピコピコ感
                    osc.frequency.value = n.f;
                    gain.gain.setValueAtTime(0, startTime + n.t); 
                    gain.gain.linearRampToValueAtTime(0.6 * v, startTime + n.t + 0.05); 
                    gain.gain.linearRampToValueAtTime(0, startTime + n.t + n.d); // 安全に消す
                    osc.connect(gain); gain.connect(audioCtx.destination); 
                    osc.start(startTime + n.t); osc.stop(startTime + n.t + n.d);
                });
            }

        }
        
        function startBgm(){ 
            if(bgmInterval) clearInterval(bgmInterval);
            if(!isBgmOn) return; 
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            bgmInterval = setInterval(()=>{ 
                if(gameState !== 'PLAYING') return; 
                if(cutinTimer > 0) return; 
                if(audioCtx.state !== 'running') return;
                
                const now = audioCtx.currentTime;
                const v = masterVolume;
                
                let melody, bass;
                if(currentLevel === 3) {
                    melody = [130.81, 138.59, 146.83, 138.59]; 
                    bass = [65.41, 69.30, 73.42, 69.30];     
                } else {
                    melody = [146.83, 164.81, 174.61, 196.00]; 
                    bass = [73.42, 73.42, 87.31, 87.31];
                }

                const mOsc=audioCtx.createOscillator(); const mG=audioCtx.createGain(); 
                mOsc.type='square'; mOsc.frequency.value=melody[frameCount%4]; 
                mG.gain.setValueAtTime(0,now); mG.gain.linearRampToValueAtTime(0.1 * v,now+0.02); mG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                mOsc.connect(mG); mG.connect(audioCtx.destination); mOsc.start(now); mOsc.stop(now+0.15); 
                
                const bOsc=audioCtx.createOscillator(); const bG=audioCtx.createGain(); 
                bOsc.type='triangle'; bOsc.frequency.value=bass[frameCount%4]; 
                bG.gain.setValueAtTime(0,now); bG.gain.linearRampToValueAtTime(0.15 * v,now+0.02); bG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                bOsc.connect(bG); bG.connect(audioCtx.destination); bOsc.start(now); bOsc.stop(now+0.15); 
            }, 180); 
        }

        function stopBgm(){ 
            if(bgmInterval) clearInterval(bgmInterval); bgmInterval=null; 
        }

        function showMsg(t, blinkCursor = false, color = '#fff') { 
            const m = document.getElementById('msg-text');
            m.innerText = t; 
            m.style.color = color; 
            document.getElementById('msg-cursor').style.display = blinkCursor ? 'inline-block' : 'none'; 
        }
        function toZen(num) { return num.toString().replace(/[0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0)); }
        function getStageName(lv) { return lv === 1 ? "１" : (lv === 2 ? "２" : "ファイナル"); }

        function drawBackground(ctx, level, frame) {
            ctx.save(); const groundY = 280; 
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, GW, GH); 
            ctx.strokeStyle = currentLevel === 3 ? '#600' : '#333'; 
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(GW, groundY); ctx.stroke(); 
            ctx.fillStyle = currentLevel === 3 ? '#311' : '#222';
            ctx.fillRect(0, groundY, GW, GH - groundY); 
            ctx.fillStyle = currentLevel === 3 ? '#422' : '#333';
            for(let i=0; i<GW; i+=80) ctx.fillRect((i - frame*6)%GW, groundY+20, 30, 2);
            for(let i=30; i<GW; i+=100) ctx.fillRect((i - frame*8)%GW, groundY+50, 40, 2);
            ctx.restore();
        }

        const vPad = document.getElementById('virtual-pad');
        const btnA = document.getElementById('v-btn-a');
        const btnB = document.getElementById('v-btn-b');
        
        function updatePadLayout() {
            const padSize = btnSize * 2 + btnGap;
            vPad.style.width = padSize + 'px';
            vPad.style.height = padSize + 'px';
            
            btnA.style.width = btnSize + 'px';
            btnA.style.height = btnSize + 'px';
            btnA.style.fontSize = Math.floor(btnSize * 0.5) + 'px';
            
            btnB.style.width = btnSize + 'px';
            btnB.style.height = btnSize + 'px';
            btnB.style.fontSize = Math.floor(btnSize * 0.5) + 'px';
        }

                function resetGame(retryBoss = false) {
            window.scrollTo(0, 0); 
            
            // 1. タイトル用のAI音楽はここで完全に止める
            titleBgmAudio.pause(); 
            musicBtn.innerText = "おんがく OFF";
            
            // 2. ピコピコBGMを一旦リセット
            stopBgm(); 

            // resetGame関数の中
                        if(!retryBoss){ 
                currentLevel = 1; score = 0; zakoKills = 0; updateStat('plays'); 
                checkpointScore = 0; 
                totalDamageTaken = 0; // ★ 最初から遊ぶ時はダメージ記録をリセット！
                cancelScoreCount = 0; // ★ 追加：弾消しスコアの上限もリセット！
            } else {


                score = Math.max(0, checkpointScore - 500); 
                updateStat('plays');
            }
            
            lives = 3; enemies = []; swordWaves = []; projectiles = []; boss = null; 
            attackFrame = -1; waitFrames = 0; playerTintTimer = 0; diedAtBoss = false;
            shake = 0; flash = 0; currentCooldownMax = baseCooldown;
            attackPower = 1; powerUpTimer = 0; cutinTimer = 0; invincibleTimer = 0;
            zakoTimer = 60;
            
            document.getElementById('ui').style.display='block'; updateUI(); 
            
            updatePadLayout();
            if (controlPattern === 2) {
                vPad.style.display = 'block';
            } else {
                vPad.style.display = 'none';
            }

            // 3. ここで本編の「ピコピコBGM」を再生開始！
            startBgm();
            
            if (localDeathCount > 0 && localDeathCount % 10 === 0 && retryBoss) {
                phase = 'wait_boss'; 
                showMsg("れいんぼー は ちゃんす", false, "#ffd700");
                waitFrames = 60; 
                waitCallback = spawnBoss;
            } else if(retryBoss) {
                phase = 'wait_boss'; 
                showMsg("ボスとの さいせん だ！(スコア没収＆-500)"); 
                waitFrames = 60; 
                waitCallback = spawnBoss;
            } else {
                phase = 'zako'; 
                showMsg("ぼうけん が はじまった！");
            }
        }


                function spawnBoss(){
            playSound('boss_appear');
            boss = { 
                x:GW+200, y:290, hp:bossHP[currentLevel-1], maxHp:bossHP[currentLevel-1], w:180, h:180, timer:-90, targetX:GW-130, shake:0, attackCount:0, restTimer:0, attackCooldown: 60, cutinDone: false,
                totalShotCount: 0, hasShotRainbow: false, rainbowTarget: Math.floor(Math.random() * 5) + 3 // ★ 追加：3〜7発目で確定レインボーを撃つ裏設定！
            };
            phase = 'boss'; 

            showMsg(currentLevel>=3?"さいしゅう ボス が あらわれた！！":"きょうりょくな ボス が あらわれた！");
            
            checkpointScore = score;
        }

        function showCutin() {
            playSound('cutin');
            const cutin = document.getElementById('cutin-container');
            const img = document.getElementById('cutin-img');
            cutin.style.display = 'flex';
            img.classList.add('animate-cutin');
            setTimeout(() => {
                cutin.style.display = 'none';
                img.classList.remove('animate-cutin');
            }, 1200);
        }

        function updateUI() {
            document.getElementById('val-lives').innerText = toZen(lives);
            document.getElementById('val-score').innerText = "SCORE: " + score;
            
            if(phase === 'boss' && boss) {
                let hpRatio = Math.max(0, boss.hp / boss.maxHp);
                ctx.save();
                ctx.fillStyle = '#111'; ctx.fillRect(GW/2 - 150, 15, 300, 10);
                ctx.fillStyle = '#ff3b30'; ctx.fillRect(GW/2 - 150, 15, 300 * hpRatio, 10);
                ctx.fillStyle = '#fff'; ctx.font = '16px DotGothic16'; ctx.textAlign = 'center'; ctx.fillText('BOSS', GW/2, 10);
                ctx.restore();
            }
            
            document.getElementById('val-lv').innerText = getStageName(currentLevel);
        }

        function drawCrescent(obj, shadowColor, fillColor = '#fff') { ctx.save(); ctx.translate(obj.x, obj.y); ctx.fillStyle = fillColor; ctx.shadowBlur = 15; ctx.shadowColor = shadowColor; ctx.beginPath(); ctx.moveTo(0, -35); ctx.quadraticCurveTo(20, 0, 0, 35); ctx.quadraticCurveTo(8, 0, 0, -35); ctx.fill(); ctx.restore(); }
        
        function drawZakoEnemy(x, y) {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = currentLevel === 3 ? '#ccc' : '#444'; 
            ctx.beginPath(); ctx.ellipse(0, 0, 30, 25, 0, 0, Math.PI*2); ctx.fill(); 
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(-20, -8, 8, 8); 
            ctx.fillRect(-4, -8, 8, 8);  
            ctx.fillStyle = '#ff0055';
            ctx.fillRect(-18, -6, 4, 4); 
            ctx.fillRect(-2, -6, 4, 4);  
            ctx.restore();
        }

        function drawHeart(x, y, size) { ctx.save(); ctx.translate(x, y - size/4); ctx.fillStyle = '#ff69b4'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(-size/2, -size/2, -size, size/3, 0, size); ctx.bezierCurveTo(size, size/3, size/2, -size/2, 0, 0); ctx.fill(); ctx.restore(); }

        function animate() {
            requestAnimationFrame(animate); 
            
            let bgFrame = (cutinTimer > 0) ? 0 : frameCount; 
            drawBackground(ctx, currentLevel, bgFrame); ctx.imageSmoothingEnabled = false; 

            if (gameState !== 'PLAYING' && gameState !== 'GAMEOVER_WAIT' && gameState !== 'CLEAR') { frameCount++; return; }
            if (waitFrames > 0) { waitFrames--; if (waitFrames === 0 && waitCallback) { let cb = waitCallback; waitCallback = null; cb(); } }
            if (shake > 0) { shake *= 0.8; if (shake < 0.5) shake = 0; } if (flash > 0) { flash *= 0.8; if (flash < 0.01) flash = 0; }
            if (playerTintTimer > 0) playerTintTimer--;

            ctx.save(); 
            if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            
            if (cutinTimer > 0) {
                cutinTimer--;
            } else {
                if (attackCooldown > 0) attackCooldown--;
                if (powerUpTimer > 0) {
                    powerUpTimer--;
                    if(invincibleTimer <= 0) { playerTint = `rgba(255, 255, 0, 0.5)`; playerTintTimer = 2; } 
                    if (powerUpTimer === 0) { attackPower = 1; showMsg("こうげきりょく が もとにもどった。"); }
                }
                if (invincibleTimer > 0) {
                    invincibleTimer--;
                    playerTint = `hsla(${frameCount * 30 % 360}, 100%, 70%, 0.6)`; playerTintTimer = 2; 
                }

                if (boss && (phase === 'boss' || phase === 'boss_dead')) {
                    if (phase === 'boss') boss.timer++; 
                    if (boss.timer > 0 && phase === 'boss') {
                        if (boss.x > boss.targetX) boss.x -= 3;
                        if (boss.shake > 0) { boss.shake *= 0.8; if(boss.shake < 0.5) boss.shake = 0; }
                        
                        if (boss.restTimer > 0) { 
                            boss.restTimer--; 
                        } else {
                            if (boss.attackCooldown > 0) boss.attackCooldown--;
                            if (boss.attackCooldown <= 0 && boss.x <= boss.targetX && gameState === 'PLAYING') {
                                                                let isUp = Math.random() < 0.5;
                                let isFeint = false;
                                let pColor = 'normal';
                                
                                boss.totalShotCount++; // ★ 追加：撃った弾数をカウント！

                                if (currentLevel === 3) {
                                    // ★ 変更：まだレインボーを撃ってなくて、予定の弾数に達したら絶対に撃つ！
                                    if (!boss.hasShotRainbow && boss.totalShotCount === boss.rainbowTarget) {
                                        pColor = 'rainbow';
                                        boss.hasShotRainbow = true;
                                        isFeint = false;
                                    } else if ((boss.hp / boss.maxHp) < sysMadHpRatio) {

                                        pColor = 'purple';
                                        isFeint = Math.random() < sysMadProb; 
                                    } else {
                                        if (Math.random() < sysCurveProb) {
                                            pColor = 'green';
                                            isFeint = true; 
                                        } else {
                                            pColor = 'blue';
                                            isFeint = false; 
                                        }
                                    }
                                }

                                let startY = isUp ? UPPER_Y : LOWER_Y; 
                                let endY = isFeint ? (isUp ? LOWER_Y : UPPER_Y) : startY;
                                let pSpeed = currentLevel === 3 ? 16 : 12 + (currentLevel * 2);

                                projectiles.push({ x: boss.x + (Math.random()-0.5)*boss.shake, y: startY, targetY: endY, speed: pSpeed, isParried: false, color: pColor });
                                
                                let nextRate = Math.max(30, 70 - (currentLevel * 10));
                                if (currentLevel === 3) nextRate = baseCooldown + 25 + Math.floor(Math.random() * 30);
                                else nextRate = Math.max(nextRate, baseCooldown + 15);
                                boss.attackCooldown = nextRate;


                                boss.attackCount++; 
                                
                                // ★ ハッカー特製：予測不能のランダムコンボシステム！
                                let shouldRest = false;
                                
                                if (currentLevel === 3) {
                                    // まだ「今回の目標回数」が決まっていなければ、3〜7の間でサイコロを振って決める！
                                    if (!boss.targetAttackCount) {
                                        boss.targetAttackCount = Math.floor(Math.random() * 5) + 3; // 3, 4, 5, 6, 7 のどれか
                                    }
                                    
                                    // 攻撃回数が、裏で決めた目標回数に達したら休む！
                                    if (boss.attackCount >= boss.targetAttackCount) {
                                        shouldRest = true;
                                    }
                                } else {
                                    // ステージ1・2：今まで通り（だいたい5〜6回で休む）
                                    if (boss.attackCount >= (4 + Math.random()*2)) {
                                        shouldRest = true;
                                    }
                                }

                                // 休むフラグが立ったら、タイマーをセットしてリセット！
                                if (shouldRest) { 
                                    boss.restTimer = 100; 
                                    boss.attackCount = 0; 
                                    boss.targetAttackCount = null; // ★ ここがキモ！休む時に目標を消して、次はまた新しくサイコロを振らせる！
                                }


                                                                
                           }
                        }
                    }
                }

                for (let i = projectiles.length - 1; i >= 0; i--) {
                    let p = projectiles[i]; p.x -= p.speed; 
                    if (!p.isParried && p.y !== p.targetY && p.x < GW / 2 + 100) { p.y += (p.targetY > p.y) ? 12 : -12; if (Math.abs(p.y - p.targetY) < 12) p.y = p.targetY; }
                    
                    if (p.x < PLAYER_X + 60 && !p.isParried && gameState === 'PLAYING') { 
                                                if (p.color === 'rainbow') {
                            projectiles.splice(i, 1); 
                            playSound('heal'); flash = 0.5;
                            score += 150; // （特典150）
                            
                            // ★ 変更：ランダム要素を完全排除！ 確定で「3秒間無敵」だけにする！
                            invincibleTimer = 180; 
                            showMsg("レインボー炎！ 3びょうかん むてき！", false, "#00ffff");
                            
                            updateUI(); 

                        } else {
                            projectiles.splice(i, 1); damagePlayer(); 
                            if(gameState !== 'PLAYING') break; 
                        }
                    }
                    else if (p.isParried && boss && phase === 'boss' && p.x > boss.x - boss.w/2) { 
                        projectiles.splice(i, 1); boss.hp -= (parryDamage * attackPower); boss.shake = 20; playSound('hit'); score += 50; updateUI(); 
                        
                        if (currentLevel === 3 && boss.hp > 0 && (boss.hp / boss.maxHp) <= 0.1 && !boss.cutinDone) {
                            boss.cutinDone = true; 
                            if(sysCutinEnabled) { cutinTimer = 72; showCutin(); }
                        }

                        if (boss.hp <= 0 && gameState === 'PLAYING') { win(); break; } 
                    }
                    else if (p.x < -100 || p.x > GW + 200) projectiles.splice(i, 1);
                }

                if (gameState === 'PLAYING') { 

                    if(phase === 'zako') {
                        zakoTimer--;
                        if (zakoTimer <= 0) {
                            enemies.push({ x: GW + 50, y: Math.random() < 0.5 ? UPPER_Y : LOWER_Y, speed: 10 + (currentLevel * 2), type: Math.random() < 0.05 ? 'heal' : 'normal' });
                            
                            let minWait = currentCooldownMax + 10; 
                            if (currentLevel === 3) {
                                zakoTimer = minWait + Math.floor(Math.random() * 15); 
                            } else {
                                zakoTimer = Math.max(minWait, 60 - (currentLevel * 10)); 
                            }
                        }
                    }

                    for (let i = enemies.length - 1; i >= 0; i--) {
                        let e = enemies[i]; if (gameState === 'PLAYING' && phase !== 'transition') e.x -= e.speed;
                        
                        if (e.x < PLAYER_X + 80 && gameState === 'PLAYING' && phase !== 'transition') {
                            if (e.type === 'heal') { 
                                if (lives < 3) lives++; showMsg("いのちのきのみ を てに入れた！", false, "#00ff00"); playSound('heal'); playerTint = 'rgba(0, 255, 0, 0.5)'; playerTintTimer = 15; updateUI(); 
                            } else { damagePlayer(); }
                            enemies.splice(i, 1); 
                            if (gameState !== 'PLAYING') break; 
                        } else if (e.x < -100) { enemies.splice(i, 1); }
                    }
                    
                    if (gameState === 'PLAYING') {
                        for (let i = swordWaves.length - 1; i >= 0; i--) {
                            let sw = swordWaves[i]; sw.x += 10; 
                            
                            let hitSomething = false;
                            for(let j = enemies.length - 1; j >= 0; j--) {
                                let e = enemies[j];
                                                                if (Math.abs(sw.x - e.x) < 80 && Math.abs(sw.y - e.y) < 30) { 
                                    if (e.type === 'heal') { 
                                        playSound('hit'); 
                                        score += 10; // ★ 神アプデ：ハートを斬り捨てた猛者にも10点を与える！
                                        updateUI(); 
                                    } 
                                    else { 
                                        playSound('hit'); score += 10; zakoKills++; updateUI(); 
                                        // ...(以下、ボスの出現処理などが続く)

                                        if(gameState === 'PLAYING' && phase === 'zako' && zakoKills >= (currentLevel === 3 ? boss3Zako : 5)) { 
                                            phase = 'wait_boss'; showMsg("・・・・・・。"); waitFrames = 120; waitCallback = spawnBoss; 
                                        } 
                                    }
                                    enemies.splice(j, 1); hitSomething = true; break; 
                                } 
                            }
                            if(hitSomething){ swordWaves.splice(i, 1); continue; }

                                    for(let j = projectiles.length - 1; j >= 0; j--) {
                                let p = projectiles[j];
                                
                                // ★ プロの技！「この1フレームの間に剣と弾がすれ違ったか？」を計算
                                let isCrossed = (sw.x >= p.x && (sw.x - 10) <= (p.x + p.speed));
                                // 通常の判定枠、または「すれ違い」が発生していればヒット！
                                let isHitX = Math.abs(sw.x - p.x) < parryWindow || isCrossed;

                                if (!p.isParried && isHitX && Math.abs(sw.y - p.y) < 30) { 
                                    hitSomething = true;
                                    
                                                                    // プレイヤーの近くで当てれば「パリィ」、遠くなら「ただ消すだけ」
                                    if (p.x < PLAYER_X + 140) { 
                                        p.isParried = true; p.speed = -40; playSound('parry'); score += 50; updateUI(); shake = 10; flash = 0.3; 
                                    } else { 
                                        projectiles.splice(j, 1); playSound('hit'); 
                                        
                                        // ★ ハッカー特製：50点上限ストッパー！
                                        if (cancelScoreCount < 50) {
                                            score += 10; 
                                            cancelScoreCount += 10; // 稼いだ点数を記録
                                        }
                                        // 50点に達した後は、音は鳴るし弾も消えるけど、スコアは一切増えない！
                                        
                                        updateUI(); shake = 5; 
                                    }
                                    break;
} 
                            }

if(hitSomething){ swordWaves.splice(i, 1); continue; }

                                                        // ★ 追加：boss.x <= boss.targetX で、ボスが定位置に着くまで一切のダメージを無効化！
                            if (boss && phase === 'boss' && boss.x <= boss.targetX && Math.abs(sw.x - boss.x) < boss.w/2) { 
                                
                                // ★ 修正：通常攻撃の火力を「1」から「2」（または好きな数字）に引き上げ！
                                boss.hp -= (5 * attackPower); 
                                
                                boss.shake = 10; swordWaves.splice(i, 1); shake = 10; playSound('hit'); 
                                
                                if (currentLevel === 3 && boss.hp > 0 && (boss.hp / boss.maxHp) <= 0.1 && !boss.cutinDone) {
                                    boss.cutinDone = true; 
                                    if(sysCutinEnabled) { cutinTimer = 72; showCutin(); }
                                }

                                if (boss.hp <= 0 && gameState === 'PLAYING') { win(); break; } 
                            }

                            else if (sw.x > GW + 100) swordWaves.splice(i, 1);
                        }

                        if (attackFrame >= 0) { attackFrame++; if (attackFrame >= 12) attackFrame = -1; }
                    }
                }
            } 
            
            if (boss && (phase === 'boss' || phase === 'boss_dead')) {
                let bx = boss.x + (Math.random() - 0.5) * boss.shake; let by = boss.y + (Math.random() - 0.5) * boss.shake;
                const bossImg = imgMonsters[Math.min(currentLevel - 1, 2)];
                
                ctx.save();
                if(currentLevel === 3 && (boss.hp / boss.maxHp) < sysMadHpRatio) {
                    ctx.filter = 'invert(0.3) sepia(1) hue-rotate(300deg) saturate(5) brightness(0.8)';
                }
                if (bossImg && bossImg.complete && bossImg.naturalWidth > 0) { ctx.drawImage(bossImg, bx - boss.w/2, by - boss.h/2, boss.w, boss.h); } else { ctx.fillStyle = '#222'; ctx.fillRect(bx - boss.w/2, by - boss.h/2, boss.w, boss.h); }
                ctx.restore();

                if(phase === 'boss') {
                    ctx.fillStyle = '#111'; ctx.fillRect(GW/2 - 150, 15, 300, 10); ctx.fillStyle = '#ff3b30'; ctx.fillRect(GW/2 - 150, 15, 300 * (boss.hp/boss.maxHp), 10);
                    ctx.fillStyle = '#fff'; ctx.font = '16px DotGothic16'; ctx.textAlign = 'center'; ctx.fillText('BOSS', GW/2, 10); ctx.textAlign = 'left';
                }
            }

            for (let i = 0; i < projectiles.length; i++) {
                let p = projectiles[i];
                if (p.isParried) { 
                    drawCrescent(p, '#ff8800', '#ffff00'); 
                } else {
                    ctx.save(); ctx.translate(p.x, p.y); ctx.scale(fireScale, fireScale);
                    if (p.color === 'rainbow') {
                        ctx.fillStyle = `hsl(${frameCount * 15 % 360}, 100%, 50%)`; ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = '#fff'; ctx.fillRect(-6, -6, 12, 12);
                    } else if (p.color === 'purple') {
                        ctx.fillStyle = '#800080'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#da70d6'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#ee82ee'; ctx.fillRect(-2, -2, 4, 4);
                    } else if (p.color === 'blue') {
                        ctx.fillStyle = '#0000ff'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#0088ff'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#00ffff'; ctx.fillRect(-2, -2, 4, 4);
                    } else if (p.color === 'green') {
                        ctx.fillStyle = '#008800'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#00ff00'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#aaffaa'; ctx.fillRect(-2, -2, 4, 4);
                    } else {
                        ctx.fillStyle = '#ff0000'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#ff8800'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#ffff00'; ctx.fillRect(-2, -2, 4, 4);
                    }
                    ctx.restore();
                }
            }

            for (let i = 0; i < enemies.length; i++) {
                let e = enemies[i];
                if (e.type === 'heal') { drawHeart(e.x, e.y, 25); } 
                else { drawZakoEnemy(e.x, e.y); } 
            }

            for (let i = 0; i < swordWaves.length; i++) { drawCrescent(swordWaves[i], '#00f3ff'); }

            let currentImg;
            if (attackFrame >= 0) { const idx = Math.floor(attackFrame / 4); currentImg = imgSword[Math.min(idx, 2)]; } else { currentImg = imgWalk[Math.floor(frameCount / 10) % 2]; }
            
            if (currentImg && currentImg.complete && currentImg.naturalWidth > 0) { 
                const pw = CHAR_SIZE * (currentImg.naturalWidth/currentImg.naturalHeight); const py = GH - CHAR_SIZE - 20;
                ctx.save(); ctx.drawImage(currentImg, PLAYER_X, py, pw, CHAR_SIZE); 
                if (playerTintTimer > 0) { ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = playerTint; ctx.fillRect(PLAYER_X, py, pw, CHAR_SIZE); }
                ctx.restore();
            }

            ctx.restore();
            
            if (flash > 0) { 
                ctx.save();
                const r = 200;
                const grad = ctx.createRadialGradient(PLAYER_X + CHAR_SIZE/2, GH - CHAR_SIZE/2, 10, PLAYER_X + CHAR_SIZE/2, GH - CHAR_SIZE/2, r);
                grad.addColorStop(0, `rgba(255, 255, 255, ${flash*0.5})`);
                grad.addColorStop(1, `rgba(255, 255, 255, 0)`);
                ctx.fillStyle = grad;
                ctx.fillRect(PLAYER_X + CHAR_SIZE/2 - r, GH - CHAR_SIZE/2 - r, r*2, r*2);
                ctx.restore();
            }
            
            updateUI(); 
            
            if (gameState === 'PLAYING' && cutinTimer <= 0) frameCount++;
        }

        function damagePlayer() {
            if (gameState !== 'PLAYING') return;
            if (invincibleTimer > 0) return; 
            
                        if (invincibleTimer > 0) return; 
            
            lives--; 
            totalDamageTaken++; // ★ 追加：被弾したら裏でダメージ回数をカウント！
            updateUI(); shake = 30; flash = 0.4; playSound('damage'); playerTint = 'rgba(255, 0, 0, 0.6)'; playerTintTimer = 15;

            
                                    // ★ ここから下が「死んだ時の処理」
            if (lives <= 0) {
                gameState = 'GAMEOVER_WAIT'; stopBgm(); 
                
                // ★ 先頭に「//」を付けて、音を鳴らす命令を一旦ストップさせる！
                 
                playSound('player_dead'); 
                playSound('gameover');    

                
                diedAtBoss = (phase === 'boss' || phase === 'boss_dead'); 


                updateStat('deaths'); showMsg("");
                localDeathCount++; 
                
                waitFrames = 200; 
                waitCallback = () => { 
                    gameState = 'GAMEOVER_PROMPT'; 
                    document.getElementById('virtual-pad').style.display = 'none'; 
                    document.getElementById('btn-retry').style.display = diedAtBoss ? 'block' : 'none'; 
                    document.getElementById('gameover-screen').style.display = 'flex';
                };
            }
        }

        function win() {
            if (gameState !== 'PLAYING') return;
            boss = null; score += 600 * currentLevel; 
            if (lives < 3) lives++; 
            updateUI(); flash = 0.8; playSound('boss_dead'); showMsg("ボス を たおした！ いのち が かいふくした！");
            phase = 'boss_dead'; 
            projectiles = []; enemies = []; swordWaves = []; 
            waitFrames = 100; 
            
                        waitCallback = () => {
                if (currentLevel >= 3) {
                    gameState = 'ENDING'; stopBgm(); updateStat('clears'); 
                    
                    // ★ 追加：神プレイスキルへの報酬（クリアボーナス）！！
                    if (totalDamageTaken === 0) {
                        score += 400;
                        showMsg("【 完璧な勝利！ 】 ノーダメージクリア +400pt", false, "#ffd700");
                    } else if (totalDamageTaken === 1) {
                        score += 200;
                        showMsg("【 素晴らしい勝利！ 】 1ダメージクリア +200pt", false, "#ffd700");
                    } else {
                        // 2ダメージ以上（ギリギリ）の時はボーナスなし
                        showMsg("すべての まものを とうばつした！");
                    }
                    updateUI(); // ★ ボーナスが入った最終スコアを画面に反映！
                    
                    document.getElementById('virtual-pad').style.display = 'none'; 
                    playSound('levelup'); 

                    
                                        setTimeout(async () => {
                        let playerName = prompt("クリアおめでとうございます！\nえいゆうのきろく に 名前をのこそう！(8文字まで)", "ゆうしゃ");
                        
                        if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                        
                        // ★ 名無し（キャンセル）検知システム！
                        if (!playerName || playerName.trim() === "") {
                            playerName = "のぶゆき"; // キャンセルされたら強制的にのぶゆき
                        } else {
                            playerName = playerName.substring(0, 8); // 普通に入力されたら8文字でカット
                        }
                        
                        // ★ if (playerName) の条件を外して、全員必ず保存するように変更
                        try {
                            await addDoc(collection(db, "leaderboard"), {
                                name: playerName,
                                score: score, // ★エラー修正：finalScoreじゃなくて「score」が正解
                                timestamp: serverTimestamp() 
                            });

                            loadLeaderboard(); 
                        } catch(e) { console.error(e); } // エラーが起きたら裏側で教えてくれるようにした
                        
                        playEndingSequence();
                        
                    }, 2500); 


                } else {
                    phase = 'transition'; document.getElementById('transition-screen').style.display = 'flex'; document.getElementById('transition-screen').innerText = `STAGE ${currentLevel + 1}`;
                    waitFrames = 150; 
                    waitCallback = () => { 
                        document.getElementById('transition-screen').style.display = 'none'; 
                        currentLevel++; phase = 'zako'; zakoKills = 0; currentCooldownMax = baseCooldown; 
                        showMsg(`ステージ ${getStageName(currentLevel)} が はじまった。`); updateUI(); startBgm(); 
                    };
                }
            };
        }

                const startHandler = (e) => {
            e.preventDefault(); 
            
            // ここで強制的にスピーカーを叩く
            initAudio(); 
            if(audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            gameState = 'PLAYING'; 
            document.getElementById('title-screen').style.display = 'none'; 
            resetGame();
        };
        
        // ★ スマホが確実に認識する「click」と「touchend（指が離れた瞬間）」に変更
        document.getElementById('start-btn').addEventListener('click', startHandler);
        document.getElementById('start-btn').addEventListener('touchend', startHandler, {passive: false});


        document.getElementById('open-user-setting').onclick = () => {
            initAudio(); 
            document.getElementById('set-btn-size').value = btnSize;
            document.getElementById('user-setting-screen').style.display = 'flex';
            
            if(document.getElementById('set-controls').value === "2") {
                updatePadLayout(); 
                vPad.style.display = 'block';
                vPad.style.zIndex = 250; 
            }
        };

        document.getElementById('set-controls').onchange = (e) => {
            if(e.target.value === "2") { updatePadLayout(); vPad.style.display = 'block'; vPad.style.zIndex = 250; }
            else { vPad.style.display = 'none'; }
        };

        document.getElementById('set-btn-size').onchange = (e) => { 
            btnSize = parseInt(e.target.value); 
            updatePadLayout(); 
        };

        document.getElementById('close-user-setting').onclick = () => {
            isBgmOn = document.getElementById('set-bgm-onoff').value === "on";
            masterVolume = parseFloat(document.getElementById('set-volume').value);
            controlPattern = parseInt(document.getElementById('set-controls').value);
            btnSize = parseInt(document.getElementById('set-btn-size').value);
            
            localStorage.setItem('nq_vol', masterVolume);
            localStorage.setItem('nq_bgm', isBgmOn);
            localStorage.setItem('nq_ctrl', controlPattern);
            localStorage.setItem('nq_btnSize', btnSize);

            titleBgmAudio.volume = masterVolume;
            
            vPad.style.zIndex = 30; 
            if (controlPattern !== 2) vPad.style.display = 'none';
            else updatePadLayout();
            
            document.getElementById('user-setting-screen').style.display = 'none';
        };

        document.getElementById('open-sys').onclick = () => {
            initAudio(); 
            let pass = prompt("管理者パスワードを入力してください (4桁)");
            if (pass === "1711") { document.getElementById('system-screen').style.display = 'flex'; } 
            else if (pass !== null) { alert("パスワードが違います"); }
        };

        document.getElementById('close-sys').onclick = () => {
            document.getElementById('system-screen').style.display = 'none';
            saveConfig(); 
        };
        
        document.getElementById('btn-retry').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none'; gameState = 'PLAYING'; resetGame(true);
        };
        document.getElementById('btn-title').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none';
            gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("・・・・・・。"); 
        };

        const executeAttack = (isUpper) => {
            if (gameState === 'PLAYING' && phase !== 'transition' && cutinTimer <= 0) {
                if (attackCooldown > 0) return; 
                attackFrame = 0; attackCooldown = currentCooldownMax; 
                swordWaves.push({x: PLAYER_X + 110, y: isUpper ? UPPER_Y : LOWER_Y}); playSound('slash');
            }
        };

        const canvasTap = (e) => {
            if (gameState === 'CLEAR') {
                gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("・・・・・・。"); 
            } else if (controlPattern === 1) {
                let rect = canvas.getBoundingClientRect(); 
                let x = (e.clientX || e.touches[0].clientX) - rect.left;
                x = x * (canvas.width / rect.width);
                executeAttack(x < GW/2);
            }
        };
        canvas.addEventListener('mousedown', canvasTap);
        canvas.addEventListener('touchstart', (e) => { if(e.target === canvas) { e.preventDefault(); canvasTap(e); } }, {passive: false});

        const tapA = (e) => { e.preventDefault(); executeAttack(true); };
        const tapB = (e) => { e.preventDefault(); executeAttack(false); };
        btnA.addEventListener('mousedown', tapA); btnA.addEventListener('touchstart', tapA, {passive: false});
        btnB.addEventListener('mousedown', tapB); btnB.addEventListener('touchstart', tapB, {passive: false});

        updatePadLayout();

        canvas.width = GW; canvas.height = GH; 
        document.getElementById('title-screen').style.display = 'flex';
        animate();
    // デバッグ用：強制エンディング関数（THE NOBLE専用カスタム版）
    window.forceEnding = function() {
        console.log("[SYSTEM] Override: Jump to Ending");

        // 1. ゲーム状態を正しく「ENDING（大文字）」にする
        gameState = 'ENDING';

        // 2. 鳴っているBGMを完全に止める
        stopBgm();
        titleBgmAudio.pause();

        // 3. 邪魔なUIや画面を強制的に隠す
        document.getElementById('ui').style.display = 'none';
        document.getElementById('virtual-pad').style.display = 'none';
        document.getElementById('title-screen').style.display = 'none';
        document.getElementById('gameover-screen').style.display = 'none';

        // 4. スコア登録などをすっ飛ばして、直接エンディングの演出関数を起動！
        playEndingSequence();
    };


        // ★ ハッカー特製：爆音（音割れ）防止システム！
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // タブが隠れた（裏に行った）瞬間：BGMのタイマーを破壊して音を止める！
                stopBgm();
                if (audioCtx && audioCtx.state === 'running') {
                    audioCtx.suspend(); // 音声エンジンごと一時停止
                }
            } else {
                // タブに戻ってきた瞬間：音声エンジンを叩き起こして、BGMを再起動！
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                // ゲームプレイ中ならBGMを再開
                if (gameState === 'PLAYING') {
                    startBgm();
                }
            }
        });


    </script>
</body>
</html>
