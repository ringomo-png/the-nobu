<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NOBUYUKIQUEST - å†’é™ºã®æ›¸</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    
    <style>
        /* ğŸŒŸ èƒŒæ™¯è‰²ã‚’çœŸã£é»’ã‹ã‚‰æ¿ƒã„ã‚°ãƒ¬ãƒ¼ã«å¤‰æ›´ã—ã€ç›®ã¸ã®è² æ‹…ã‚’è»½æ¸› */
        body { margin: 0; background-color: #1a1a1a; color: #fff; font-family: 'DotGothic16', sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; overflow: hidden; user-select: none; }
        #game-container { position: relative; display: flex; flex-direction: column; width: 1000px; max-width: 100vw; height: 100vh; background: #1a1a1a; }
        #game-area { position: relative; flex: 1; background: #1a1a1a; overflow: hidden; border-bottom: 2px solid #333; border-top: 2px solid #333; }
        
        canvas { display: block; width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        
        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; font-size: 18px; text-shadow: 2px 2px 0 #000; display: none; }
        #val-score { color: #ffd700; margin-left: 15px; }
        #val-lv { color: #00f3ff; margin-right: 15px; }
        .retro-hp { color: #fff; margin-top: 5px; }
        .heart-icon { color: #ff3b30; }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã®èƒŒæ™¯ã‚‚å¤‰æ›´ */
        #message-box { height: 90px; background-color: #1a1a1a; border: 2px solid #555; border-radius: 6px; margin: 10px; padding: 12px 15px; box-sizing: border-box; font-size: 18px; line-height: 1.5; color: #fff; display: flex; align-items: flex-start; }
        
        /* ğŸŒŸ ç‚¹æ»…ã‚’ãƒã‚¤ãƒ«ãƒ‰ã«ï¼ˆå®Œå…¨ã«æ¶ˆãˆãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰ */
        .blink { animation: blinker 1.5s linear infinite; margin-left: auto; align-self: flex-end;}
        @keyframes blinker { 50% { opacity: 0.4; } }

        /* ğŸŒŸ ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª¿æ•´ã€‚justify-contentã‚’ä½¿ã‚ãšã€marginã§è¦–è¦šçš„ãªä¸­å¤®ã¸ */
        #title-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: flex; flex-direction: column; align-items: center; z-index: 50; box-sizing: border-box; padding-top: 5vh; }
        
        .stats-box { border: 2px solid #555; border-radius: 8px; background: rgba(30,30,30,0.8); padding: 15px 30px; font-size: 18px; color: #ccc; text-align: center; margin-bottom: 3vh; min-width: 250px; }
        .stat-val { color: #ff3b30; font-size: 22px; font-weight: bold; margin: 0 5px; }
        .stat-rate { color: #00f3ff; font-size: 22px; font-weight: bold; margin: 0 5px; }

        /* ãƒœã‚¿ãƒ³ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’èª¿æ•´ã—ã¦è¦–è¦šçš„ãªä¸­å¤®ã¸é…ç½® */
        .start-prompt { 
            font-size: clamp(24px, 5vw, 40px); 
            color: #fff; margin: 2vh 0 4vh 0; cursor: pointer; padding: 15px 6vw; 
            border: 3px solid #fff; border-radius: 10px; background: #222; 
            transition: 0.2s; pointer-events: auto; font-weight: bold; 
            white-space: nowrap; max-width: 90%; text-align: center; box-sizing: border-box;
        }
        .start-prompt:active { background: #fff; color: #000; }
        
        .sys-btn-title { font-size: 16px; color: #888; cursor: pointer; pointer-events: auto; text-decoration: underline; margin-top: auto; margin-bottom: 20px; }
        .sys-btn-title:hover { color: #fff; }

        #system-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.95); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 200; overflow-y: auto; }
        .sys-box { border: 2px solid #555; padding: 25px; background: #1a1a1a; text-align: center; font-size: 16px; }
        .sys-box-inner { text-align: right; margin-bottom: 20px; line-height: 1.8; }
        .sys-box input { width: 50px; font-size: 16px; margin-left: 10px; background: #222; color: #fff; border: 1px solid #555; text-align: center; font-family: 'DotGothic16'; }

        #gameover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(20,20,20,0.8); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .gameover-text { color: #ff3b30; font-size: 32px; margin-bottom: 40px; font-weight: bold; letter-spacing: 2px; }
        .go-btn { font-size: 24px; color: #fff; margin: 10px; cursor: pointer; padding: 10px 30px; border: 2px solid #fff; transition: 0.2s; background: #222; pointer-events: auto; }
        .go-btn:active { background: #fff; color: #000; }

        #transition-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a1a; display: none; justify-content: center; align-items: center; z-index: 300; font-size: 40px; letter-spacing: 4px; }

        #ending-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; justify-content: center; align-items: center; z-index: 400; overflow: hidden; cursor: pointer; }
        #ending-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0.4; pointer-events: none; }
        #credits { position: absolute; width: 100%; text-align: center; color: #fff; font-size: 24px; line-height: 2; z-index: 401; animation: scrollUp 15s linear forwards; pointer-events: none; }
        @keyframes scrollUp { 0% { transform: translateY(100vh); } 100% { transform: translateY(-100vh); } }

        .assets { display: none; }
    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="title-screen">
            <svg width="800" height="180" viewBox="0 0 900 200" style="max-width: 90vw; margin-bottom: 2vh;">
                <path id="title-curve" d="M 50,150 Q 450,-20 850,150" fill="transparent" />
                <text font-family="'DotGothic16', sans-serif" font-size="90" fill="#fff" font-weight="bold" filter="drop-shadow(5px 5px 0 #444)">
                    <textPath href="#title-curve" startOffset="50%" text-anchor="middle">NOBUYUKI QUEST</textPath>
                </text>
            </svg>
            
            <div class="stats-box">
                <div style="color:#ffd700; margin-bottom:10px;">ã€ ã›ã‹ã„ãƒ‡ãƒ¼ã‚¿ ã€‘</div>
                æ­»äº¡æ•°: <span class="stat-val" id="global-deaths">-</span> å›<br>
                ã‚¯ãƒªã‚¢ç‡: <span class="stat-rate" id="global-clear-rate">-.-</span> %
            </div>

            <div class="start-prompt blink" id="start-btn">ï¼ ã¼ã†ã‘ã‚“ ã« ã§ã‚‹ ï¼œ</div>
            
            <div class="sys-btn-title" id="open-sys">âš™ï¸ ã‚·ã‚¹ãƒ†ãƒ </div>
        </div>

        <div id="system-screen">
            <div class="sys-box">
                <div style="color:#ffd700; margin-bottom:15px; font-size:22px;">ã€ ã‚·ã‚¹ãƒ†ãƒ  ã¡ã‚‡ã†ã›ã„ ã€‘</div>
                <div class="sys-box-inner">
                    BOSS 1 HP: <input type="number" id="hp-boss1" value="30"><br>
                    BOSS 2 HP: <input type="number" id="hp-boss2" value="50"><br>
                    BOSS 3 HP: <input type="number" id="hp-boss3" value="100"><br>
                    BOSS 3 å‰ã®ã‚¶ã‚³æ•°: <input type="number" id="sys-zako3" value="15"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    æ•µã®ç‚ã®å¤§ãã•(å€ç‡): <input type="number" id="sys-fire-size" value="1.2" step="0.1"><br>
                    ãƒ‘ãƒªã‚£åˆ¤å®šã®åºƒã•: <input type="number" id="sys-parry" value="10"><br>
                    æ”»æ’ƒã®ç¡¬ç›´(F): <input type="number" id="sys-cooldown" value="25"><br>
                    <hr style="border-color:#333; margin:10px 0;">
                    ç™ºç‹‚ãƒ¢ãƒ¼ãƒ‰çªå…¥HP(%): <input type="number" id="sys-mad-hp" value="50"><br>
                    ç™ºç‹‚æ™‚ã®æ›²ãŒã‚‹å¼¾ç¢ºç‡(%): <input type="number" id="sys-mad-prob" value="40"><br>
                </div>
                <button id="close-sys" style="cursor:pointer; font-family:'DotGothic16'; font-size:18px; color:#fff; background:#222; border:2px solid #fff; padding:8px 30px;">ã‘ã£ã¦ã„</button>
            </div>
        </div>

        <div id="transition-screen">STAGE 2</div>

        <div id="ending-screen">
            <video id="ending-video" src="game2.MOV" playsinline muted loop></video>
            <div id="credits">
                <br><br><br><br>
                NOBUYUKI QUEST<br><br><br>
                ã™ã¹ã¦ã® ã¾ã‚‚ã®ã‚’ ã¨ã†ã°ã¤ã—ãŸï¼<br><br><br>
                DIRECTOR / NOBUYUKI<br><br>
                PROGRAM / AI<br><br><br><br>
                THANK YOU FOR PLAYING<br><br><br><br><br>
                <span style="font-size:16px;">ï¼ ã‚¿ãƒƒãƒ—ã§ ã‚¿ã‚¤ãƒˆãƒ«ã¸ ï¼œ</span>
            </div>
        </div>

        <div id="game-area">
            <div id="ui">
                <div>ã‚¹ãƒ†ãƒ¼ã‚¸ï¼š<span id="val-lv">ï¼‘</span></div>
                <div class="retro-hp">ã„ã®ã¡ï¼š<span class="heart-icon">â™¥</span> Ã— <span id="val-lives">3</span> <span id="val-score">SCORE: 0</span></div>
            </div>
            
            <div id="gameover-screen">
                <div class="gameover-text">ã‚ãªãŸã¯ ã—ã‚“ã§ã—ã¾ã£ãŸ</div>
                <div class="go-btn" id="btn-retry">ï¼ ãƒœã‚¹ã‹ã‚‰ ãƒªãƒˆãƒ©ã‚¤</div>
                <div class="go-btn" id="btn-title">ï¼ ã‚¿ã‚¤ãƒˆãƒ«ã¸ ã‚‚ã©ã‚‹</div>
            </div>

            <canvas id="view-canvas"></canvas>
        </div>

        <div id="message-box">
            <span id="msg-text">ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ã€‚</span>
            <span class="blink" id="msg-cursor" style="display:none;">â–¼</span>
        </div>
    </div>

    <div class="assets">
        <img id="walk1" src="1-uma.nobu.png"><img id="walk2" src="2-uma.nobu.png">
        <img id="sword1" src="3-uma.nobu.png"><img id="sword2" src="4-uma.nobu.png"><img id="sword3" src="5-uma.nobu.png">
        <img id="monster1" src="monster1.png"><img id="monster2" src="monster2.png"><img id="monster3" src="monster3.png">
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc, increment } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDrDTNLFOC93bBsjzcBrdLt4miPgrat2zY",
            authDomain: "nobuyukiquest.firebaseapp.com",
            projectId: "nobuyukiquest",
            storageBucket: "nobuyukiquest.firebasestorage.app",
            messagingSenderId: "504992212070",
            appId: "1:504992212070:web:79f0ccca4e1d136bd639a7"
        };

        let db;
        try { 
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            loadGlobalStats(); 
        } catch(e) { console.log("Firebase Error", e); }

        async function loadGlobalStats() {
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    document.getElementById('global-deaths').innerText = data.deaths || 0;
                    let rate = data.plays > 0 ? ((data.clears || 0) / data.plays) * 100 : 0;
                    document.getElementById('global-clear-rate').innerText = rate.toFixed(1);
                } else { 
                    await setDoc(docRef, { plays: 0, deaths: 0, clears: 0 }); 
                }
            } catch (e) {}
        }

        async function updateStat(type) { 
            if(!db) return;
            try {
                const docRef = doc(db, "stats", "global");
                await setDoc(docRef, { [type]: increment(1) }, { merge: true });
                if(type === 'deaths' || type === 'clears') loadGlobalStats();
            } catch (e) {}
        }

        const canvas = document.getElementById('view-canvas'); 
        const ctx = canvas.getContext('2d');
        const GW = 1000, GH = 400; const PLAYER_X = 50; const CHAR_SIZE = 180;
        const UPPER_Y = 280, LOWER_Y = 340; 

        let bossHP = [30, 50, 100];
        let parryWindow = 10;
        let baseCooldown = 25;
        let madHpRatio = 0.5; 
        let madProb = 0.4;    
        let boss3Zako = 15; 
        let fireScale = 1.2; 

        let gameState = 'TITLE', currentLevel = 1, score = 0, frameCount = 0, lives = 3;
        let phase = 'zako', zakoKills = 0, enemies = [], swordWaves = [], projectiles = [], boss = null;
        let attackFrame = -1, attackCooldown = 0, currentCooldownMax = baseCooldown, playerTint = '', playerTintTimer = 0;
        let diedAtBoss = false;
        let waitFrames = 0, waitCallback = null, shake = 0, flash = 0; 
        
        let attackPower = 1; 
        let powerUpTimer = 0;

        const imgWalk = [document.getElementById('walk1'), document.getElementById('walk2')];
        const imgSword = [document.getElementById('sword1'), document.getElementById('sword2'), document.getElementById('sword3')];
        const imgMonsters = [document.getElementById('monster1'), document.getElementById('monster2'), document.getElementById('monster3')];

        let audioCtx, audioInitialized = false, bgmInterval, titleBgmInterval;
        
        function initAudio() {
            if (!audioInitialized || audioCtx.state === 'suspended') {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') audioCtx.resume();
                audioInitialized = true;
                if(gameState === 'TITLE' && !titleBgmInterval) playTitleBgm();
            }
        }
        window.addEventListener('mousedown', initAudio, { once: true });
        window.addEventListener('touchstart', initAudio, { once: true });

        function playSound(type) {
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const now = audioCtx.currentTime;

            if(type === 'slash'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.6, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'hit'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.8, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'parry'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(3000, now + 0.1);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.2);
            }
            if(type === 'heal'){
                const notes = [659.25, 880.00, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, now + i*0.08); gain.gain.linearRampToValueAtTime(0.4, now + i*0.08 + 0.02); gain.gain.exponentialRampToValueAtTime(0.01, now + i*0.08 + 0.3);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now + i*0.08); osc.stop(now + i*0.08 + 0.3);
                });
            }
            if(type === 'damage'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 0.4);
            }
            if(type === 'player_dead'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now + 1.0);
                gain.gain.setValueAtTime(1.0, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 1.0);
                
                const bufferSize = audioCtx.sampleRate * 0.5;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type = 'lowpass'; noiseFilter.frequency.value = 800;
                const noiseGain = audioCtx.createGain();
                noiseGain.gain.setValueAtTime(1.0, now); noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
                noise.start(now);
            }
            if(type === 'boss_dead'){
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(10, now + 2.0);
                gain.gain.setValueAtTime(0.9, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 2.0);
                osc.connect(gain); gain.connect(audioCtx.destination); osc.start(now); osc.stop(now + 2.0);
            }
            if(type === 'gameover'){
                const startTime = now + 0.8; 
                const notes = [196.00, 185.00, 174.61, 130.81];
                notes.forEach((freq, i) => {
                    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                    osc.type = 'triangle'; osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, startTime + i*0.4); gain.gain.linearRampToValueAtTime(0.7, startTime + i*0.4 + 0.1); gain.gain.exponentialRampToValueAtTime(0.01, startTime + i*0.4 + 1.0);
                    osc.connect(gain); gain.connect(audioCtx.destination); osc.start(startTime + i*0.4); osc.stop(startTime + i*0.4 + 1.0);
                });
            }
        }

        function playTitleBgm(){ 
            if(titleBgmInterval) clearInterval(titleBgmInterval);
            if(!audioCtx || audioCtx.state === 'suspended') return;
            const melody = [440.00, 523.25, 659.25, 523.25]; 
            titleBgmInterval = setInterval(()=>{ 
                const now = audioCtx.currentTime; const osc=audioCtx.createOscillator(); const g=audioCtx.createGain(); 
                osc.type='square'; osc.frequency.value=melody[frameCount%4]; 
                g.gain.setValueAtTime(0.08,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                osc.connect(g); g.connect(audioCtx.destination); osc.start(now); osc.stop(now+0.15); 
            }, 220); 
        }
        function stopTitleBgm(){ if(titleBgmInterval) clearInterval(titleBgmInterval); titleBgmInterval=null; }
        
        function startBgm(){ 
            if(bgmInterval) clearInterval(bgmInterval);
            if(!audioCtx) initAudio();
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            bgmInterval = setInterval(()=>{ 
                if(gameState !== 'PLAYING') return; 
                const now = audioCtx.currentTime;
                
                let melody, bass;
                if(currentLevel === 3) {
                    melody = [130.81, 138.59, 146.83, 138.59]; 
                    bass = [65.41, 69.30, 73.42, 69.30];     
                } else {
                    melody = [146.83, 164.81, 174.61, 196.00]; 
                    bass = [73.42, 73.42, 87.31, 87.31];
                }

                const mOsc=audioCtx.createOscillator(); const mG=audioCtx.createGain(); 
                mOsc.type='square'; mOsc.frequency.value=melody[frameCount%4]; 
                mG.gain.setValueAtTime(0.1,now); mG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                mOsc.connect(mG); mG.connect(audioCtx.destination); mOsc.start(now); mOsc.stop(now+0.15); 
                
                const bOsc=audioCtx.createOscillator(); const bG=audioCtx.createGain(); 
                bOsc.type='triangle'; bOsc.frequency.value=bass[frameCount%4]; 
                bG.gain.setValueAtTime(0.15,now); bG.gain.exponentialRampToValueAtTime(0.001,now+0.15); 
                bOsc.connect(bG); bG.connect(audioCtx.destination); bOsc.start(now); bOsc.stop(now+0.15); 
            }, 180); 
        }
        function stopBgm(){ if(bgmInterval) clearInterval(bgmInterval); bgmInterval=null; }

        function showMsg(t, blinkCursor = false) { document.getElementById('msg-text').innerText = t; document.getElementById('msg-cursor').style.display = blinkCursor ? 'inline-block' : 'none'; }
        function toZen(num) { return num.toString().replace(/[0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0)); }
        function getStageName(lv) { return lv === 1 ? "ï¼‘" : (lv === 2 ? "ï¼’" : "ãƒ•ã‚¡ã‚¤ãƒŠãƒ«"); }

        function drawBackground(ctx, level, frame) {
            ctx.save(); const groundY = 280; 
            /* ğŸŒŸ èƒŒæ™¯è‰²ã‚’æ¿ƒã„ã‚°ãƒ¬ãƒ¼ã«å¤‰æ›´ */
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, GW, GH); 
            ctx.strokeStyle = currentLevel === 3 ? '#600' : '#333'; 
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(GW, groundY); ctx.stroke(); 
            ctx.fillStyle = currentLevel === 3 ? '#311' : '#222';
            ctx.fillRect(0, groundY, GW, GH - groundY); 
            ctx.fillStyle = currentLevel === 3 ? '#422' : '#333';
            for(let i=0; i<GW; i+=80) ctx.fillRect((i - frame*6)%GW, groundY+20, 30, 2);
            for(let i=30; i<GW; i+=100) ctx.fillRect((i - frame*8)%GW, groundY+50, 40, 2);
            ctx.restore();
        }

        function resetGame(retryBoss = false) {
            stopBgm(); stopTitleBgm(); 
            if(!retryBoss){ currentLevel=1; score=0; zakoKills=0; updateStat('plays'); }
            
            lives=3; enemies=[]; swordWaves=[]; projectiles=[]; boss=null; 
            attackFrame=-1; waitFrames=0; playerTintTimer=0; diedAtBoss=false;
            shake=0; flash=0; currentCooldownMax = baseCooldown;
            attackPower = 1; powerUpTimer = 0; 
            
            document.getElementById('ui').style.display='block'; updateUI(); 
            startBgm();
            
            if(retryBoss) {
                phase='wait_boss'; 
                showMsg("ãƒœã‚¹ã¨ã® ã•ã„ã›ã‚“ ã ï¼"); waitFrames = 60; waitCallback = spawnBoss;
            } else {
                phase='zako'; showMsg("ã¼ã†ã‘ã‚“ ãŒ ã¯ã˜ã¾ã£ãŸï¼");
            }
        }

        function spawnBoss(){
            boss = { x:GW+200, y:290, hp:bossHP[currentLevel-1], maxHp:bossHP[currentLevel-1], w:180, h:180, timer:-90, targetX:GW-150, shake:0, attackCount:0, restTimer:0, attackCooldown: 60 };
            phase = 'boss'; showMsg(currentLevel>=3?"ã•ã„ã—ã‚…ã† ãƒœã‚¹ ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼ï¼":"ãã‚‡ã†ã‚Šã‚‡ããª ãƒœã‚¹ ãŒ ã‚ã‚‰ã‚ã‚ŒãŸï¼");
        }

        function updateUI() {
            document.getElementById('val-lives').innerText = toZen(lives);
            document.getElementById('val-score').innerText = "SCORE: " + score;
            document.getElementById('val-lv').innerText = getStageName(currentLevel);
        }

        function drawCrescent(obj, shadowColor, fillColor = '#fff') { ctx.save(); ctx.translate(obj.x, obj.y); ctx.fillStyle = fillColor; ctx.shadowBlur = 15; ctx.shadowColor = shadowColor; ctx.beginPath(); ctx.moveTo(0, -35); ctx.quadraticCurveTo(20, 0, 0, 35); ctx.quadraticCurveTo(8, 0, 0, -35); ctx.fill(); ctx.restore(); }
        function drawHeart(x, y, size) { ctx.save(); ctx.translate(x, y - size/4); ctx.fillStyle = '#ff69b4'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.bezierCurveTo(-size/2, -size/2, -size, size/3, 0, size); ctx.bezierCurveTo(size, size/3, size/2, -size/2, 0, 0); ctx.fill(); ctx.restore(); }

        function animate() {
            requestAnimationFrame(animate); 
            drawBackground(ctx, currentLevel, frameCount); ctx.imageSmoothingEnabled = false; 

            if (gameState !== 'PLAYING' && gameState !== 'GAMEOVER_WAIT' && gameState !== 'CLEAR') { frameCount++; return; }
            if (waitFrames > 0) { waitFrames--; if (waitFrames === 0 && waitCallback) { let cb = waitCallback; waitCallback = null; cb(); } }
            if (shake > 0) { shake *= 0.8; if (shake < 0.5) shake = 0; } if (flash > 0) { flash *= 0.8; if (flash < 0.01) flash = 0; }
            if (playerTintTimer > 0) playerTintTimer--;

            ctx.save(); if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
            if (attackCooldown > 0) attackCooldown--;

            if (powerUpTimer > 0) {
                powerUpTimer--;
                playerTint = `hsla(${frameCount * 15 % 360}, 100%, 50%, 0.5)`; 
                playerTintTimer = 2; 
                if (powerUpTimer === 0) {
                    attackPower = 1; showMsg("ã“ã†ã’ãã‚Šã‚‡ã ãŒ ã‚‚ã¨ã«ã‚‚ã©ã£ãŸã€‚");
                }
            }

            // --- BOSS ---
            if (boss && (phase === 'boss' || phase === 'boss_dead')) {
                if (phase === 'boss') boss.timer++; 
                if (boss.timer > 0 && phase === 'boss') {
                    if (boss.x > boss.targetX) boss.x -= 3;
                    if (boss.shake > 0) { boss.shake *= 0.8; if(boss.shake < 0.5) boss.shake = 0; }
                    
                    if (boss.restTimer > 0) { 
                        boss.restTimer--; 
                    } else {
                        if (boss.attackCooldown > 0) boss.attackCooldown--;
                        
                        if (boss.attackCooldown <= 0 && boss.x <= boss.targetX && gameState === 'PLAYING') {
                            let isUp = Math.random() < 0.5;
                            let isFeint = false;
                            let pColor = 'normal';

                            if (currentLevel === 3) {
                                if (Math.random() < 0.01) {
                                    pColor = 'rainbow';
                                } else if ((boss.hp / boss.maxHp) < madHpRatio) {
                                    pColor = 'green'; isFeint = Math.random() < madProb;
                                } else {
                                    pColor = 'blue'; isFeint = Math.random() < 0.20; 
                                }
                            }

                            let startY = isUp ? UPPER_Y : LOWER_Y; 
                            let endY = isFeint ? (isUp ? LOWER_Y : UPPER_Y) : startY;
                            let pSpeed = currentLevel === 3 ? 16 : 12 + (currentLevel * 2);

                            projectiles.push({ x: boss.x + (Math.random()-0.5)*boss.shake, y: startY, targetY: endY, speed: pSpeed, isParried: false, color: pColor });
                            
                            let nextRate = Math.max(30, 70 - (currentLevel * 10));
                            if (currentLevel === 3) nextRate = baseCooldown + 25 + Math.floor(Math.random() * 30);
                            else nextRate = Math.max(nextRate, baseCooldown + 15);
                            boss.attackCooldown = nextRate;

                            boss.attackCount++; 
                            if (boss.attackCount >= (currentLevel === 3 ? 6 + Math.random()*4 : 4 + Math.random()*2)) { 
                                boss.restTimer = 100; boss.attackCount = 0; 
                            }
                        }
                    }
                }
                
                let bx = boss.x + (Math.random() - 0.5) * boss.shake; let by = boss.y + (Math.random() - 0.5) * boss.shake;
                const bossImg = imgMonsters[Math.min(currentLevel - 1, 2)];
                if (bossImg && bossImg.complete && bossImg.naturalWidth > 0) { ctx.drawImage(bossImg, bx - boss.w/2, by - boss.h/2, boss.w, boss.h); } else { ctx.fillStyle = '#222'; ctx.fillRect(bx - boss.w/2, by - boss.h/2, boss.w, boss.h); }
                
                if(phase === 'boss') {
                    ctx.fillStyle = '#111'; ctx.fillRect(GW/2 - 150, 15, 300, 10); ctx.fillStyle = '#ff3b30'; ctx.fillRect(GW/2 - 150, 15, 300 * (boss.hp/boss.maxHp), 10);
                    ctx.fillStyle = '#fff'; ctx.font = '16px DotGothic16'; ctx.textAlign = 'center'; ctx.fillText('BOSS', GW/2, 10); ctx.textAlign = 'left';
                }
            }

            // --- PROJECTILES ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                let p = projectiles[i]; p.x -= p.speed; 
                if (!p.isParried && p.y !== p.targetY && p.x < GW / 2 + 100) { p.y += (p.targetY > p.y) ? 12 : -12; if (Math.abs(p.y - p.targetY) < 12) p.y = p.targetY; }
                
                if (p.isParried) { 
                    drawCrescent(p, '#ff8800', '#ffff00'); 
                } else {
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.scale(fireScale, fireScale);
                    if (p.color === 'rainbow') {
                        ctx.fillStyle = `hsl(${frameCount * 15 % 360}, 100%, 50%)`; ctx.fillRect(-10, -10, 20, 20); ctx.fillStyle = '#fff'; ctx.fillRect(-6, -6, 12, 12);
                    } else if (p.color === 'blue') {
                        ctx.fillStyle = '#0000ff'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#0088ff'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#00ffff'; ctx.fillRect(-2, -2, 4, 4);
                    } else if (p.color === 'green') {
                        ctx.fillStyle = '#008800'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#00ff00'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#aaffaa'; ctx.fillRect(-2, -2, 4, 4);
                    } else {
                        ctx.fillStyle = '#ff0000'; ctx.fillRect(-10, -10, 20, 20); ctx.fillRect(10, -6, 8, 12); ctx.fillRect(18, -2, 6, 8); 
                        ctx.fillStyle = '#ff8800'; ctx.fillRect(-6, -6, 12, 12); ctx.fillStyle = '#ffff00'; ctx.fillRect(-2, -2, 4, 4);
                    }
                    ctx.restore();
                }

                if (p.x < PLAYER_X + 60 && !p.isParried && gameState === 'PLAYING') { 
                    if (p.color === 'rainbow') {
                        projectiles.splice(i, 1); lives = 3; attackPower = 1.5; powerUpTimer = 600; 
                        playSound('heal'); showMsg("ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ã®ç‚ï¼ãŸã„ã‚Šã‚‡ããœã‚“ã‹ã„ï¼10ã³ã‚‡ã†ã‹ã‚“ ã“ã†ã’ãã‚Šã‚‡ã1.5ã°ã„ï¼"); updateUI(); flash = 0.5;
                    } else {
                        projectiles.splice(i, 1); damagePlayer(); break; 
                    }
                }
                else if (p.isParried && boss && phase === 'boss' && p.x > boss.x - boss.w/2) { 
                    projectiles.splice(i, 1); boss.hp -= (5 * attackPower); boss.shake = 20; playSound('hit'); score += 50; updateUI(); 
                    if (boss.hp <= 0) { win(); break; } 
                }
                else if (p.x < -100 || p.x > GW + 200) projectiles.splice(i, 1);
            }

            // --- ENEMIES ---
            if(phase === 'zako' && frameCount % Math.max(25, 60 - (currentLevel * 10)) === 0){
                enemies.push({ x: GW + 50, y: Math.random() < 0.5 ? UPPER_Y : LOWER_Y, speed: 10 + (currentLevel * 2), type: Math.random() < 0.05 ? 'heal' : 'normal' });
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i]; if (gameState === 'PLAYING' && phase !== 'transition') e.x -= e.speed;
                
                if (e.type === 'heal') { drawHeart(e.x, e.y, 25); } 
                else { ctx.fillStyle = currentLevel === 3 ? '#ccc' : '#444'; ctx.beginPath(); ctx.ellipse(e.x, e.y, 30, 25, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#ff0055'; ctx.fillRect(e.x - 15, e.y - 5, 8, 3); }
                
                if (e.x < PLAYER_X + 80 && gameState === 'PLAYING' && phase !== 'transition') {
                    if (e.type === 'heal') { 
                        if (lives < 3) lives++; showMsg("ã„ã®ã¡ã®ãã®ã¿ ã‚’ ã¦ã«å…¥ã‚ŒãŸï¼ ã„ã®ã¡ãŒ ã‹ã„ãµãã—ãŸï¼"); playSound('heal'); playerTint = 'rgba(0, 255, 0, 0.5)'; playerTintTimer = 15; updateUI(); 
                    } else { damagePlayer(); }
                    enemies.splice(i, 1); 
                    if (gameState !== 'PLAYING') break; 
                } else if (e.x < -100) { enemies.splice(i, 1); }
            }

            // --- SWORD WAVES ---
            for (let i = swordWaves.length - 1; i >= 0; i--) {
                let sw = swordWaves[i]; sw.x += 10; drawCrescent(sw, '#00f3ff'); 
                
                let hitSomething = false;
                for(let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.abs(sw.x - e.x) < 80 && Math.abs(sw.y - e.y) < 30) { 
                        if (e.type === 'heal') { playSound('hit'); } 
                        else { 
                            playSound('hit'); score += 10; zakoKills++; updateUI(); 
                            if(phase === 'zako' && zakoKills >= (currentLevel === 3 ? boss3Zako : 5)) { 
                                phase = 'wait_boss'; showMsg("ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ã€‚"); waitFrames = 120; waitCallback = spawnBoss; 
                            } 
                        }
                        enemies.splice(j, 1); hitSomething = true; break; 
                    } 
                }
                if(hitSomething){ swordWaves.splice(i, 1); continue; }

                for(let j = projectiles.length - 1; j >= 0; j--) {
                    let p = projectiles[j];
                    if (!p.isParried && Math.abs(sw.x - p.x) < parryWindow && Math.abs(sw.y - p.y) < 30) { 
                        hitSomething = true;
                        if (p.x < PLAYER_X + 220) { p.isParried = true; p.speed = -40; playSound('parry'); score += 50; updateUI(); shake = 10; flash = 0.3; } 
                        else { projectiles.splice(j, 1); playSound('hit'); score += 10; updateUI(); shake = 5; }
                        break;
                    } 
                }
                if(hitSomething){ swordWaves.splice(i, 1); continue; }

                if (boss && phase === 'boss' && Math.abs(sw.x - boss.x) < boss.w/2) { 
                    boss.hp -= (1 * attackPower); boss.shake = 10; swordWaves.splice(i, 1); shake = 10; playSound('hit'); 
                    if (boss.hp <= 0) { win(); break; } 
                }
                else if (sw.x > GW + 100) swordWaves.splice(i, 1);
            }

            // --- NOBUYUKI ---
            let currentImg;
            if (attackFrame >= 0) { const idx = Math.floor(attackFrame / 4); currentImg = imgSword[Math.min(idx, 2)]; attackFrame++; if (attackFrame >= 12) attackFrame = -1; } else { currentImg = imgWalk[Math.floor(frameCount / 10) % 2]; }
            
            if (currentImg && currentImg.complete && currentImg.naturalWidth > 0) { 
                const pw = CHAR_SIZE * (currentImg.naturalWidth/currentImg.naturalHeight); const py = GH - CHAR_SIZE - 20;
                ctx.save(); ctx.drawImage(currentImg, PLAYER_X, py, pw, CHAR_SIZE); 
                if (playerTintTimer > 0) { ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = playerTint; ctx.fillRect(PLAYER_X, py, pw, CHAR_SIZE); }
                ctx.restore();
            }

            ctx.restore();
            /* ğŸŒŸ ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã®å¼·ã•ã‚’åŠåˆ†ä»¥ä¸‹ã«è»½æ¸› */
            if (flash > 0) { ctx.fillStyle = `rgba(255, 255, 255, ${flash*0.5})`; ctx.fillRect(0, 0, GW, GH); }
            if (gameState === 'PLAYING') frameCount++;
        }

        function damagePlayer() {
            if (gameState !== 'PLAYING') return;
            lives--; updateUI(); shake = 30; flash = 0.4; playSound('damage'); playerTint = 'rgba(255, 0, 0, 0.6)'; playerTintTimer = 15;
            if (lives <= 0) {
                gameState = 'GAMEOVER_WAIT'; stopBgm(); 
                playSound('player_dead'); // ğŸŒŸ æ­»äº¡æ™‚ã®çˆ†ç™ºã‚µã‚¦ãƒ³ãƒ‰
                playSound('gameover');    // ğŸŒŸ çˆ†ç™ºã®ã‚ã¨ã«ãƒ¡ãƒ­ãƒ‡ã‚£ãŒé³´ã‚‹
                
                diedAtBoss = (phase === 'boss' || phase === 'boss_dead'); 
                updateStat('deaths'); showMsg("ã‚ãªãŸã¯ ã—ã‚“ã§ã—ã¾ã£ãŸã€‚");
                
                waitFrames = 200; 
                waitCallback = () => { 
                    gameState = 'GAMEOVER_PROMPT'; 
                    document.getElementById('btn-retry').style.display = diedAtBoss ? 'block' : 'none'; 
                    document.getElementById('gameover-screen').style.display = 'flex';
                };
            }
        }

        function win() {
            if (gameState !== 'PLAYING') return;
            boss = null; score += 500 * currentLevel; 
            if (lives < 3) lives++; 
            updateUI(); flash = 0.8; playSound('boss_dead'); showMsg("ãƒœã‚¹ ã‚’ ãŸãŠã—ãŸï¼ ã„ã®ã¡ ãŒ ã‹ã„ãµãã—ãŸï¼");
            phase = 'boss_dead'; 
            projectiles = []; enemies = []; swordWaves = []; 
            waitFrames = 100; 
            
            waitCallback = () => {
                if (currentLevel >= 3) {
                    gameState = 'ENDING'; stopBgm(); updateStat('clears'); showMsg("ã™ã¹ã¦ã® ã¾ã‚‚ã®ã‚’ ã¨ã†ã°ã¤ã—ãŸï¼");
                    document.getElementById('ending-screen').style.display = 'flex';
                    document.getElementById('ending-video').play().catch(e => console.log(e)); 
                } else {
                    phase = 'transition'; 
                    document.getElementById('transition-screen').style.display = 'flex'; 
                    document.getElementById('transition-screen').innerText = `STAGE ${currentLevel + 1}`;
                    waitFrames = 150; 
                    waitCallback = () => { 
                        document.getElementById('transition-screen').style.display = 'none'; 
                        currentLevel++; phase = 'zako'; zakoKills = 0; currentCooldownMax = baseCooldown; 
                        showMsg(`ã‚¹ãƒ†ãƒ¼ã‚¸ ${getStageName(currentLevel)} ãŒ ã¯ã˜ã¾ã£ãŸã€‚`); updateUI(); startBgm(); 
                    };
                }
            };
        }

        // ğŸŒŸ ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ã‚¿ãƒ¼ãƒˆ
        const startHandler = (e) => {
            e.preventDefault();
            initAudio(); 
            gameState = 'PLAYING'; document.getElementById('title-screen').style.display = 'none'; resetGame();
        };
        document.getElementById('start-btn').addEventListener('mousedown', startHandler);
        document.getElementById('start-btn').addEventListener('touchstart', startHandler, {passive: false});

        // ğŸŒŸ ã‚·ã‚¹ãƒ†ãƒ è¨­å®š
        document.getElementById('open-sys').onclick = () => {
            initAudio(); // ç”»é¢ã‚’è§¦ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§BGMèµ·å‹•
            let pass = prompt("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (4æ¡)");
            if (pass === "1711") { document.getElementById('system-screen').style.display = 'flex'; } 
            else if (pass !== null) { alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™"); }
        };

        document.getElementById('close-sys').onclick = () => {
            bossHP = [parseInt(document.getElementById('hp-boss1').value), parseInt(document.getElementById('hp-boss2').value), parseInt(document.getElementById('hp-boss3').value)];
            boss3Zako = parseInt(document.getElementById('sys-zako3').value) || 15;
            fireScale = parseFloat(document.getElementById('sys-fire-size').value) || 1.2; // ğŸŒŸ ç‚ã®å¤§ãã•ä¿å­˜
            parryWindow = parseInt(document.getElementById('sys-parry').value) || 10;
            baseCooldown = parseInt(document.getElementById('sys-cooldown').value) || 25;
            madHpRatio = (parseInt(document.getElementById('sys-mad-hp').value) || 50) / 100;
            madProb = (parseInt(document.getElementById('sys-mad-prob').value) || 40) / 100;
            currentCooldownMax = baseCooldown;
            document.getElementById('system-screen').style.display = 'none';
        };
        
        document.getElementById('btn-retry').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none'; gameState = 'PLAYING'; resetGame(true);
        };
        document.getElementById('btn-title').onclick = (e) => {
            e.stopPropagation(); document.getElementById('gameover-screen').style.display = 'none';
            gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ã€‚"); playTitleBgm();
        };

        document.getElementById('ending-screen').onclick = () => {
            document.getElementById('ending-screen').style.display = 'none';
            gameState = 'TITLE'; document.getElementById('ui').style.display = 'none'; document.getElementById('title-screen').style.display = 'flex'; showMsg("ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ãƒ»ã€‚"); playTitleBgm();
        };

        const canvasTap = (e) => {
            if (gameState === 'PLAYING' && phase !== 'transition') {
                if (attackCooldown > 0) return; 
                attackFrame = 0; attackCooldown = currentCooldownMax; 
                let rect = canvas.getBoundingClientRect(); 
                let x = (e.clientX || e.touches[0].clientX) - rect.left;
                x = x * (canvas.width / rect.width);
                swordWaves.push({x: PLAYER_X + 110, y: x < GW/2 ? UPPER_Y : LOWER_Y}); playSound('slash');
            }
        };

        canvas.addEventListener('mousedown', canvasTap);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); canvasTap(e); }, {passive: false});

        canvas.width = GW; canvas.height = GH; 
        
        // ğŸŒŸ åˆå›èµ·å‹•æ™‚ã¯ãã®ã¾ã¾ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã‚’è¡¨ç¤º
        document.getElementById('title-screen').style.display = 'flex';
        animate();
    </script>
</body>
</html>
